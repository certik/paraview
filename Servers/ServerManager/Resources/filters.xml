<ServerManagerConfiguration>
  <ProxyGroup name="filters">

   <ExtractLocationsProxy name="ProbeLocationOverTime"
                          class="vtkPExtractArraysOverTime"
                          label="Probe Location over Time">
     <Documentation> 
This filter extracts cell and point variables at a given location over time. The output is a 1D rectilinear grid where the x coordinates correspond to time (the same array is also copied to a point array named Time or TimeData (if Time exists in the input)). The point values are interpolated from the nearby cells, ie those of the cell the location lies in. 
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <DoubleVectorProperty 
        name="Locations"
        command="AddLocation"
        clean_command="RemoveAllLocations"
        repeat_command="1"
        number_of_elements_per_command="3"
        number_of_elements="3"
        update_self="1"
        label="Locations" 
        default_values="0 0 0">
        <Documentation>
          The list of locations that will be added to the selection produced by the selection source. Only the first location is currently plotted.
        </Documentation>
     </DoubleVectorProperty> 

     <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">
        </Proxy>
     </SubProxy>

     <Hints>
       <PropertyGroup type="Handle" label="Location Widget">
         <Property function="WorldPosition" name="Locations" />
       </PropertyGroup>
     </Hints>

     <!-- End ProbeLocationOverTime -->
   </ExtractLocationsProxy>
    
   <ExtractSelectionProxy name="ExtractPointsOverTime"
                          class="vtkPExtractArraysOverTime"
                          label="Plot Point over Time"
                          selection_field_type="POINT">
     <Documentation>
This filter extracts the variables associated with a vertex over time. The output is a 1D rectilinear grid where the x coordinates correspond to time (the same array is also copied to a point array named Time or TimeData (if Time exists in the input)).  The input point coordinates are copied to a point array named Point Coordinates or Points (if Point Coordinates exists in the input).
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <IdTypeVectorProperty 
        name="Indices"
        command="AddIndex"
        clean_command="RemoveAllIndices"
        repeat_command="1"
        number_of_elements_per_command="2"
        number_of_elements="2"
        update_self="1"
        label="Indices" 
        default_values="0 0">
        <Documentation>
          The list of IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IdTypeVectorProperty 
        name="GlobalIDs"
        command="AddGlobalID"
        clean_command="RemoveAllGlobalIDs"
        repeat_command="1"
        number_of_elements_per_command="1"
        number_of_elements="1"
        update_self="1"
        label="Global IDs"
        default_values="0">
        <Documentation>
          The list of Global IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IntVectorProperty
        name="UseGlobalIDs"
        command="SetUseGlobalIDs"
        number_of_elements="1"
        update_self="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Use GlobalIDs (instead of Indices) to generate the selection.
        </Documentation>
     </IntVectorProperty>

     <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">
        </Proxy>
     </SubProxy>
     <!-- End ExtractPointsOverTime -->
   </ExtractSelectionProxy>

   <ExtractSelectionProxy name="ExtractCellsOverTime"
                          class="vtkPExtractArraysOverTime"
                          label="Plot Cell over Time"
                          selection_field_type="CELL">
     <Documentation>
This filter extracts the variables associated with a cell over time. The output is a 1D rectilinear grid where the x coordinates correspond to time (the same array is also copied to a point array named Time or TimeData (if Time exists in the input)).
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <IdTypeVectorProperty 
        name="Indices"
        command="AddIndex"
        clean_command="RemoveAllIndices"
        repeat_command="1"
        number_of_elements_per_command="2"
        number_of_elements="2"
        update_self="1"
        label="Indices" 
        default_values="0 0">
        <Documentation>
          The list of IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IdTypeVectorProperty 
        name="GlobalIDs"
        command="AddGlobalID"
        clean_command="RemoveAllGlobalIDs"
        repeat_command="1"
        number_of_elements_per_command="1"
        number_of_elements="1"
        update_self="1"
        label="Global IDs"
        default_values="0">
        <Documentation>
          The list of Global IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IntVectorProperty
        name="UseGlobalIDs"
        command="SetUseGlobalIDs"
        number_of_elements="1"
        update_self="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Use GlobalIDs (instead of Indices) to generate the selection.
        </Documentation>
     </IntVectorProperty>

     <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">
        </Proxy>
     </SubProxy>
     <!-- End ExtractCellsOverTime -->
   </ExtractSelectionProxy>

   <SourceProxy name="ExtractFieldDataOverTime"
                          class="vtkExtractTemporalFieldData"
                          label="Plot Field Variable over Time">
     <Documentation>
This filter extracts the variables that reside in a dataset's field data and are defined over time. The output is a 1D rectilinear grid where the x coordinates correspond to time (the same array is also copied to a point array named Time or TimeData (if Time exists in the input)).
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>
     <!-- End ExtractFieldDatasOverTime -->
   </SourceProxy>

   <SourceProxy name="ImageShrink" class="vtkImageShrink3D" label="Image Shrink">
    <Documentation
      short_help="Subsample an image/volume."
      long_help="Reduce the size of an image/volume by subsampling.">
      The Image Shrink filter reduces the size of an image/volume dataset by subsampling it (i.e., extracting every nth pixel/voxel in integer multiples). The sbsampling rate can be set separately for each dimension of the image/volume.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Image Shrink filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="ShrinkFactors" 
        command="SetShrinkFactors" 
        number_of_elements="3"
        animateable="1"
        default_values="1 1 1" > 
       <IntRangeDomain name="range" min="1" max="100"/>
       <Documentation>
         The value of this property indicates the amount by which to shrink along each axis.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Averaging" 
        command="SetAveraging" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, an average of neighborhood scalar values will be used as the output scalar value for each output point. If its value is 0, only subsampling will be performed, and the original scalar values at the points will be retained.
       </Documentation>
     </IntVectorProperty>
   <!-- End ImageShrink -->
   </SourceProxy>

   <SourceProxy name="SurfaceVectors" class="vtkSurfaceVectors" label="Surface Vectors">
     <Documentation
          long_help="This filter constrains vectors to lie on a surface."
          short_help="This filter constrains vectors to lie on a surface.">
The Surface Vectors filter is used for 2D data sets. It constrains vectors to lie in a surface by removing components of the vectors normal to the local surface.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Surface Vectors filter.
           </Documentation>
     </InputProperty>

     <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         animateable="0"> 
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              This property specifies the name of the input vector array to process.
            </Documentation>
     </StringVectorProperty> 

     <IntVectorProperty 
        name="ConstraintMode" 
        command="SetConstraintMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Parallel"/>
         <Entry value="1" text="Perpendicular"/>
         <Entry value="2" text="PerpendicularScale"/>
       </EnumerationDomain>
       <Documentation>
         This property specifies whether the vectors will be parallel or perpendicular to the surface. If the value is set to PerpendicularScale (2), then the output will contain a scalar array with the dot product of the surface normal and the vector at each point.
       </Documentation>
     </IntVectorProperty>

   <!-- End SurfaceVectors -->
   </SourceProxy>

   <SourceProxy name="IntegrateAttributes" class="vtkIntegrateAttributes" 
     label="Integrate Variables">
     <Documentation 
        long_help="This filter integrates cell and point attributes."
        short_help="Integrates over lines, surfaces or vectors.">
The Integrate Attributes filter integrates point and cell data over lines and surfaces.  It also computes length of lines, area of surface, or volume.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Integrate Attributes filter.
           </Documentation>
      </InputProperty>
   <Hints>
     <Visibility replace_input="0" />
     <!-- View can be used to specify the preferred view for the proxy -->
     <View type="SpreadSheetView" />
   </Hints>
   <!-- End IntegrateAttributes -->
   </SourceProxy>

   <SourceProxy name="IntegrateFlowThroughSurface" class="vtkIntegrateFlowThroughSurface" label="Surface Flow">
     <Documentation
        long_help="This filter integrates flow through a surface."
        short_help="This filter integrates flow through a surface.">
The flow integration fitler  integrates the dot product of a point flow vector field and surface normal. It computes the net flow across the 2D surface. It operates on any type of dataset and produces an unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Surface Flow filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              The value of this property specifies the name of the input vector array containing the flow vector field.
            </Documentation>
      </StringVectorProperty> 

   <!-- End IntegrateFlowThroughSurface -->
   </SourceProxy>

   <SourceProxy name="AllToN" class="vtkAllToNRedistributePolyData"
                label="All to N"
                multiprocess_support="multiple_processes">
      <Documentation
         long_help="Redistribute data to a subset of available processes."
         short_help="Repartition data filter.">
The All to N filter is available when ParaView is run in parallel. It redistributes the data so that it is located on the number of processes specified in the Number of Processes entry box. It also does load-balancing of the data among these processes. This filter operates on polygonal data and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the All to N filter.
           </Documentation>
      </InputProperty>

      <IntVectorProperty 
         name="NumberOfProcesses" 
         command="SetNumberOfProcesses" 
         number_of_elements="1"
         default_values="1"
         label="Number of Processes"> 
         <Documentation>
           Set the number of processes across which to split the input data.
         </Documentation>
      </IntVectorProperty>         
   <!-- End AllToN -->
   </SourceProxy>

   <SourceProxy name="Balance" class="vtkBalancedRedistributePolyData"
                multiprocess_support="multiple_processes">
      <Documentation
         long_help="Balance data among available processes."
         short_help="Load balance filter.">
The Balance filter is available when ParaView is run in parallel. It does load-balancing so that all processes have the same number of cells. It operates on polygonal data sets and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Balance filter.
           </Documentation>
      </InputProperty>
   <!-- End Balance -->
   </SourceProxy>

   <SourceProxy name="AppendAttributes" class="vtkMergeArrays"
    label="Append Attributes">
      <Documentation
         long_help="Copies geometry from first input.  Puts all of the arrays into the output."
         short_help="Puts all input arrays into the single output.">
The Append Attributes filter takes multiple input data sets with the same geometry and merges their point and cell attributes to produce a single output containing all the point and cell attributes of the inputs. Any inputs without the same number of points and cells as the first input are ignored. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Append Attributes filter.
           </Documentation>
      </InputProperty>
         
   <!-- End AppendAttributes -->
   </SourceProxy>

   <SourceProxy name="AppendPolyData" class="vtkAppendPolyData"
      label="Append Geometry">
      <Documentation
         long_help="Takes an input of multiple poly data parts and output has only one part."
         short_help="Append multiple parts into one.">
The Append Geometry filter operates on multiple polygonal data sets. It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Append Geometry filter.
           </Documentation>
      </InputProperty>
   <!-- End AppendPolyData -->
   </SourceProxy>

   <SourceProxy name="Append" class="vtkAppendFilter" label="Append Datasets">
      <Documentation
         long_help="Takes an input of multiple datasets and output has only one unstructured grid."
         short_help="Append multiple datasets into one.">
The Append Datasets filter operates on multiple data sets of any type (polygonal, structured, etc.). It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the datasets to be merged into a single dataset by the Append Datasets filter.
           </Documentation>
      </InputProperty>
   <!-- End AppendDataSet -->
   </SourceProxy>

   <SourceProxy name="CellCenters" class="vtkCellCenters" label="Cell Centers">
     <Documentation
        long_help="Create a point (no geometry) at the center of each input cell."
        short_help="Convert cells to vertices.">
The Cell Centers filter places a point at the center of each cell in the input data set. The center computed is the parametric center of the cell, not necessarily the geometric or bounding box center. The cell attributes of the input will be associated with these newly created points of the output. You have the option of creating a vertex cell per point in the outpuut. This is useful because vertex cells are rendered, but points are not. The points themselves could be used for placing glyphs (using the Glyph filter). The Cell Centers filter takes any type of data set as input and produces a polygonal data set as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Cell Centers filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="VertexCells" 
        command="SetVertexCells" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If set to 1, a vertex cell will be generated per point in the output. Otherwise only points will be generated.
       </Documentation>
     </IntVectorProperty>
   <!-- End CellCenters -->
   </SourceProxy>

   <SourceProxy name="CellDataToPointData" class="vtkPCellDataToPointData"
     label="Cell Data to Point Data">
     <Documentation
        long_help="Create point attributes by averaging cell attributes."
        short_help="Convert cell data to point data.">
The Cell Data to Point Data filter averages the values of the cell attributes of the cells surrounding a point to compute point attributes. The Cell Data to Point Data filter operates on any type of data set, and the output data set is of the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell"/>
          <Documentation>
            This property specifies the input to the Cell Data to Point Data filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="PassCellData" 
        command="SetPassCellData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, then the input cell data is passed through to the output; otherwise, only the generated point data will be available in the output.
       </Documentation>
     </IntVectorProperty>
   <!-- End CellDataToPointData -->
   </SourceProxy>

   <SourceProxy name="CleanPolyData" class="vtkCleanPolyData"
     label="Clean">
     <Documentation
        long_help="Merge coincident points if they do not meet a feature edge critera."
        short_help="Merge coincident points.">
The Clean filter takes polygonal data as input and generates polygonal data as output. This filter can merge duplicate points, remove unused points, and transform degenerate cells into their appropriate forms (e.g., a triangle is converted into a line if two of its points are merged).
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Clean filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the whole data set will be processed at once so that cleaning the data set always produces the same results. If it is set to 0, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory; however the results are not guaranteed to be the same as they would be if the Piece invariant option was on. Setting this option to 0 may produce seams in the output dataset when ParaView is run in parallel.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Tolerance"
        command="SetTolerance"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range" min="0" max="1" />
       <Documentation>
         If merging nearby points (see PointMerging property) and not using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging as a fraction of the length of the diagonal of the bounding box of the input data set.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="AbsoluteTolerance"
        command="SetAbsoluteTolerance"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         If merging nearby points (see PointMerging property) and using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging in the spatial units of the input data set.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ToleranceIsAbsolute" 
        command="SetToleranceIsAbsolute" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         This property determines whether to use absolute or relative (a percentage of the bounding box) tolerance when performing point merging.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertLinesToPoints" 
        command="SetConvertLinesToPoints" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, degenerate lines (a "line" whose endpoints are at the same spatial location) will be converted to points.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertPolysToLines" 
        command="SetConvertPolysToLines" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, degenerate polygons (a "polygon" with only two distinct point coordinates) will be converted to lines.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertStripsToPolys" 
        command="SetConvertStripsToPolys" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, degenerate triangle strips (a triangle "strip" containing only one triangle) will be converted to triangles.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PointMerging" 
        command="SetPointMerging" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, then points will be merged if they are within the specified Tolerance or AbsoluteTolerance (see the Tolerance and AbsoluteTolerance propertys), depending on the value of the ToleranceIsAbsolute property. (See the ToleranceIsAbsolute property.) If this property is set to 0, points will not be merged.
       </Documentation>
     </IntVectorProperty>
   <!-- End CleanPolyData -->
   </SourceProxy>

   <SourceProxy name="CleanUnstructuredGrid" class="vtkCleanUnstructuredGrid"
      label="Clean to Grid">
      <Documentation
         long_help="This filter merges points and converts the data set to unstructured grid."
         short_help="Merge points.">
The Clean to Grid filter merges points that are within a tolerance of 1/100,000 of the length of the diagonal of the bounding box of the data set. It also converts the data set to an unstructured grid. You may wish to do this if you want to apply a filter to your data set that is available for unstructured grids but not for the initial type of your data set (e.g., applying warp vector to volumetric data). The Clean to Grid filter operates on any type of data set.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Clean to Grid filter.
           </Documentation>
      </InputProperty>
   <!-- End CleanUnstructuredGrid -->
   </SourceProxy>

   <SourceProxy name="Delaunay2D" class="vtkDelaunay2D" label="Delaunay 2D">
      <Documentation
         long_help="Create 2D Delaunay triangulation of input points. 
It expects a vtkPointSet as input and produces vtkPolyData as output. 
The points are expected to be in a mostly planar distribution."
         short_help="Create 2D Delaunay triangulation of input points.">
Delaunay2D is a filter that constructs a 2D Delaunay triangulation from a list of input points. These points may be represented by any dataset of type vtkPointSet and subclasses. The output of the filter is a polygonal dataset containing a triangle mesh.

The 2D Delaunay triangulation is defined as the triangulation that satisfies the Delaunay criterion for n-dimensional simplexes (in this case n=2 and the simplexes are triangles). This criterion states that a circumsphere of each simplex in a triangulation contains only the n+1 defining points of the simplex. In two dimensions, this translates into an optimal triangulation. That is, the maximum interior angle of any triangle is less than or equal to that of any possible triangulation.

Delaunay triangulations are used to build topological structures from unorganized (or unstructured) points. The input to this filter is a list of points specified in 3D, even though the triangulation is 2D. Thus the triangulation is constructed in the x-y plane, and the z coordinate is ignored (although carried through to the output). You can use the option ProjectionPlaneMode in order to compute the best-fitting plane to the set of points, project the points and that plane and then perform the triangulation using their projected positions and then use it as the plane in which the triangulation is performed.

The Delaunay triangulation can be numerically sensitive in some cases. To prevent problems, try to avoid injecting points that will result in triangles with bad aspect ratios (1000:1 or greater). In practice this means inserting points that are "widely dispersed", and enables smooth transition of triangle sizes throughout the mesh. (You may even want to add extra points to create a better point distribution.) If numerical problems are present, you will see a warning message to this effect at the end of the triangulation process.

Warning:
Points arranged on a regular lattice (termed degenerate cases) can be triangulated in more than one way (at least according to the Delaunay criterion). The choice of triangulation (as implemented by this algorithm) depends on the order of the input points. The first three points will form a triangle; other degenerate points will not break this triangle.

Points that are coincident (or nearly so) may be discarded by the algorithm. This is because the Delaunay triangulation requires unique input points. The output of the Delaunay triangulation is supposedly a convex hull. In certain cases this implementation may not generate the convex hull.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input dataset to the Delaunay 2D filter.
           </Documentation>
      </InputProperty>
      <IntVectorProperty 
        name="ProjectionPlaneMode" 
        command="SetProjectionPlaneMode" 
        number_of_elements="1"
        default_values="0"> 
       <EnumerationDomain name="enum">
         <Entry value="0" text="XY Plane"/>
<!--         <Entry value="1" text="Perpendicular"/> -->
         <Entry value="2" text="Best-Fitting Plane"/>
       </EnumerationDomain>
       <Documentation>
         This property determines type of projection plane to use in performing the triangulation.
       </Documentation>
     </IntVectorProperty>
     <DoubleVectorProperty name="Alpha"
       command="SetAlpha"
       number_of_elements="1"
       animateable="1"
       default_values="0.0">
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property controls the output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.
       </Documentation>
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Tolerance"
       command="SetTolerance"
       number_of_elements="1"
       animateable="1"
       default_values="0.00001">
       <DoubleRangeDomain name="range" min="0" max="1.0" />
       <Documentation>
         This property specifies a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.
       </Documentation>
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Offset"
       command="SetOffset"
       number_of_elements="1"
       animateable="1"
       default_values="1.0">
       <DoubleRangeDomain name="range" min="0.75"/>
       <Documentation>
         This property is a multiplier to control the size of the initial, bounding Delaunay triangulation.
       </Documentation>
     </DoubleVectorProperty>
     <IntVectorProperty name="BoundingTriangulation"
       command="SetBoundingTriangulation"
       number_of_elements="1"
       animateable="1"
       default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, bounding triangulation points (and associated triangles) are included in the output. These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.
       </Documentation>
     </IntVectorProperty>
   </SourceProxy>

   <SourceProxy name="PVConnectivityFilter" class="vtkPVConnectivityFilter"
      label="Connectivity">
      <Documentation
          long_help="Mark connected components with integer point attribute array."
          short_help="Find connected components.">
The Connectivity filter assigns a region id to connected components of the input data set. (The region id is assigned as a point scalar value.) This filter takes any data set type as input and produces unstructured grid output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Connectivity filter.
           </Documentation>
      </InputProperty>
   <!-- End PVConnectivityFilter -->
   </SourceProxy>

   <SourceProxy name="ImageClip" class="vtkImageClip" label="Crop">
    <Documentation
       long_help="Efficiently extract an area/volume of interest from a 2-d image or 3-d volume."
       short_help="Extract a volume of interest.">
The Crop filter extracts an area/volume of interest from a 2D image or a 3D volume by allowing the user to specify the minimum and maximum extents of each dimension of the data. Both the input and output of this filter are uniform rectilinear data.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Crop filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="OutputWholeExtent" 
        command="SetOutputWholeExtent" 
        number_of_elements="6"
        default_values="0 0 0 0 0 0"> 
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
       <Documentation>
         This property gives the minimum and maximum point index (extent) in each dimension for the output dataset.
       </Documentation>
     </IntVectorProperty>
    <Hints>
      <Visibility replace_input="0" />
    </Hints>
   <!-- End ImageClip -->
   </SourceProxy>

   <SourceProxy name="Curvatures" class="vtkCurvatures" label="Curvature">
    <Documentation
       long_help="This filter will compute the gaussian or mean curvature of the mesh at each point."
       short_help="Compute the curvature at each point.">
The Curvature filter computes the curvature at each point in a polygonal data set. This filter supports both Gaussian and mean curvatures.

; the type can be selected from the Curvature type menu button.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Curvature filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="InvertMeanCurvature" 
        command="SetInvertMeanCurvature" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the mean curvature calculation will be inverted. This is useful for meshes with inward-pointing normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="CurvatureType" 
        command="SetCurvatureType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Gaussian"/>
         <Entry value="1" text="Mean"/>
       </EnumerationDomain>
       <Documentation>
         This propery specifies which type of curvature to compute.
       </Documentation>
     </IntVectorProperty>
   <!-- End Curvatures -->
   </SourceProxy>

   <SourceProxy name="DecimatePro" class="vtkDecimatePro" label="Decimate">
     <Documentation
        long_help="Simplify a polygonal model using an adaptive edge collapse algorithm.  This filter works with triangles only."
        short_help="Reduce the number of triangles in a model.">
The Decimate filter reduces the number of triangles in a polygonal data set. Because this filter only operates on triangles, first run the Triangulate filter on a dataset that contains polygons other than triangles.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Decimate filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="TargetReduction"
         command="SetTargetReduction"
         number_of_elements="1"
         animateable="1"
         default_values="0.9" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          This property specifies the desired reduction in the total number of polygons in the output dataset. For example, if the TargetReduction value is 0.9, the Decimate filter will attempt to produce an output dataset that is 10% the size of the input.)
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="PreserveTopology" 
        command="SetPreserveTopology" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, decimation will not split the dataset or produce holes, but it may keep the filter from reaching the reduction target. If it is set to 0, better reduction can occur (reaching the reduction target), but holes in the model may be produced.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="15.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
       <Documentation>
         The value of thie property is used in determining where the data set may be split. If the angle between two adjacent triangles is greater than or equal to the FeatureAngle value, then their boundary is considered a feature edge where the dataset can be split.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="BoundaryVertexDeletion" 
        command="SetBoundaryVertexDeletion" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, then vertices on the boundary of the dataset can be removed. Setting the value of this property to 0 preserves the boundary of the dataset, but it may cause the filter not to reach its reduction target.
       </Documentation>
     </IntVectorProperty>
   <!-- End DecimatePro -->
   </SourceProxy>

   <SourceProxy name="D3" class="vtkDistributedDataFilter" label="D3"
                multiprocess_support="multiple_processes">
    <Documentation
       long_help="Repartition a data set into load-balanced spatially convex regions.  Create ghost cells if requested."
       short_help="Repartition a data set.">
The D3 filter is available when ParaView is run in parallel. It operates on any type of data set to evenly divide it across the processors into spatially contiguous regions. The output of this filter is of type unstructured grid.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the D3 filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="BoundaryMode" 
        command="SetBoundaryMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Assign cells uniquely"/>
         <Entry value="1" text="Duplicate cells"/>
         <Entry value="2" text="Divide cells"/>
       </EnumerationDomain>
       <Documentation>
         This property determines how cells that lie on processor boundaries are handled. The "Assign cells uniquely" option assigns each boundary cell to exactly one process, which is useful for isosurfacing. Selecting "Duplicate cells" causes the cells on the boundaries to be copied to each process that shares that boundary. The "Divide cells" option breaks cells across process boundary lines so that pieces of the cell lie in different processes. This option is useful for volume rendering.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseMinimalMemory" 
        command="SetUseMinimalMemory" 
        number_of_elements="1"
        default_values="0"
        label="Minimal Memory"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the D3 filter requires communication routines to use minimal memory than without this restriction.
       </Documentation>
     </IntVectorProperty>
   <!-- End D3 -->
   </SourceProxy>

   <SourceProxy name="ElevationFilter" class="vtkElevationFilter" label="Elevation">
     <Documentation
        long_help="Create point attribute array by projecting points onto an elevation vector."
        short_help="Create a point array representing elevation.">
The Elevation filter generates point scalar values for an input dataset along a specified direction vector.

The Input menu allows the user to select the data set to which this filter will be applied. Use the Scalar range entry boxes to specify the minimum and maximum scalar value to be generated. The Low Point and High Point define a line onto which each point of the data set is projected. The minimum scalar value is associated with the Low Point, and the maximum scalar value is associated with the High Point. The scalar value for each point in the data set is determined by the location along the line to which that point projects.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input dataset to the Elevation filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="ScalarRange"
         command="SetScalarRange"
         number_of_elements="2"
         default_values="0 1" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property determines the range into which scalars will be mapped.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="LowPoint"
         label="Low Point"
         command="SetLowPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 0" >
         <BoundsDomain name="range" mode="normal" default_mode="min" >
           <RequiredProperties>
             <Property name="Input" function="Input" />
           </RequiredProperties>
         </BoundsDomain>
         <Documentation>
           This property defines one end of the direction vector (small scalar values).
         </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="HighPoint"
         label="High Point"
         command="SetHighPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 1" >
         <BoundsDomain name="range" mode="normal" default_mode="max" >
           <RequiredProperties>
             <Property name="Input" function="Input" />
           </RequiredProperties>
         </BoundsDomain>
         <Documentation>
           This property defines the other end of the direction vector (large scalar values).
         </Documentation>
      </DoubleVectorProperty>

      <Hints>
        <PropertyGroup type="Line" label="Elevation Widget">
          <Property function="Point1WorldPosition" name="LowPoint" />
          <Property function="Point2WorldPosition" name="HighPoint" />
        </PropertyGroup>
      </Hints>
   <!-- End ElevationFilter -->
   </SourceProxy>

   <SourceProxy name="CTHPart" class="vtkExtractCTHPart"
    label="Extract CTH Parts">
    <Documentation
       long_help="Create a surface from a CTH volume fraction."
       short_help="Extract a part from a CTH dataset.">
Extract CTH Parts is a specialized filter for visualizing the data from a CTH simulation. It first converts the selected cell-centered arrays to point-centered ones. It then contours each array at a value of 0.5. The user has the option of clipping the resulting surface(s) with a plane. This filter only operates on unstructured data. It produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell" 
                            number_of_components="1"/>
          <Documentation>
            This property specifies the input to the Extract CTH Parts filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipPlane" command="SetClipPlane"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="None" />
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             This property specifies whether to clip the dataset, and if so, it also specifies the parameters of the plane with which to clip.
           </Documentation>
     </ProxyProperty>

     <StringVectorProperty 
        name="AddDoubleVolumeArrayName"
        command="AddDoubleVolumeArrayName" 
        clean_command="RemoveDoubleVolumeArrayNames"
        repeat_command="1"
        number_of_elements_per_command="1"
        label="Double Volume Arrays">
        <Documentation>
          This property specifies the name(s) of the volume fraction array(s) for generating parts.
        </Documentation>
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_DOUBLE" >
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
            not set the default value for this property
            using the domain when the proxy is created -->
          <NoDefault />
        </Hints>
     </StringVectorProperty> 

     <StringVectorProperty 
        name="AddFloatVolumeArrayName"
        command="AddFloatVolumeArrayName" 
        clean_command="RemoveFloatVolumeArrayNames"
        repeat_command="1"
        number_of_elements_per_command="1"
        label="Float Volume Arrays">
        <Documentation>
          This property specifies the name(s) of the volume fraction array(s) for generating parts.
        </Documentation>
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_FLOAT" >
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
            not set the default value for this property
            using the domain when the proxy is created -->
          <NoDefault />
        </Hints>
     </StringVectorProperty> 

     <StringVectorProperty 
        name="AddUnsignedCharVolumeArrayName"
        command="AddUnsignedCharVolumeArrayName" 
        clean_command="RemoveUnsignedCharVolumeArrayNames"
        repeat_command="1"
        number_of_elements_per_command="1"
        label="Unsigned Character Volume Arrays">
        <Documentation>
          This property specifies the name(s) of the volume fraction array(s) for generating parts.
        </Documentation>
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_UNSIGNED_CHAR" >
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
            not set the default value for this property
            using the domain when the proxy is created -->
          <NoDefault />
        </Hints>
     </StringVectorProperty> 

     <DoubleVectorProperty
        name="VolumeFractionSurfaceValue"
        command="SetVolumeFractionSurfaceValue"
        number_of_elements="1"
        default_values="0.1"
        label="Volume Fraction Value">
       <DoubleRangeDomain name="range" min="0" max="1" />
       <Documentation>
         The value of this property is the volume fraction value for the surface.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End CTHPart -->
   </SourceProxy>

   <SourceProxy name="ExtractEdges" class="vtkExtractEdges"
      label="Extract Edges">
     <Documentation
        long_help="Extract edges of 2D and 3D cells as lines."
        short_help="Covert data to wireframe.">
The Extract Edges filter produces a wireframe version of the input dataset by extracting all the edges of the dataset's cells as lines. This filter operates on any type of data set and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Edges filter.
           </Documentation>
      </InputProperty>
   <!-- End ExtractEdges -->
   </SourceProxy>

   <SourceProxy name="DataSetSurfaceFilter" class="vtkDataSetSurfaceFilter"
      label="Extract Surface">
     <Documentation
        long_help="Extract a 2D boundary surface using neighbor relations to eliminate internal faces."
        short_help="Extract 2D boundary surface.">
The Extract Surface filter extracts the polygons forming the outer surface of the input dataset. This filter operates on any type of data and produces polygonal data as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Surface filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, internal surfaces along process boundaries will be removed. NOTE: Enabling this option might cause multiple executions of the data source because more information is needed to remove internal surfaces.
       </Documentation>
     </IntVectorProperty>
   <!-- End DataSetSurfaceFilter -->
   </SourceProxy>

   <SourceProxy name="Calculator" class="vtkArrayCalculator">
    <Documentation
       long_help="Compute new attribute arrays as function of existing arrays."
       short_help="Compute new attribute arrays.">
The Calculator filter computes a new data array or new point coordinates as a function of existing scalar or vector arrays. If point-centered arrays are used in the computation of a new data array, the resulting array will also be point-centered. Similarly, computations using cell-centered arrays will produce a new cell-centered array. If the function is computing point coordinates, the result of the function must be a three-component vector. The Calculator interface operates similarly to a scientific calculator. In creating the function to evaluate, the standard order of operations applies.
Each of the calculator functions is described below. Unless otherwise noted, enclose the operand in parentheses using the ( and ) buttons.
Clear: Erase the current function (displayed in the read-only text box above the calculator buttons).
/: Divide one scalar by another. The operands for this function are not required to be enclosed in parentheses.
*: Multiply two scalars, or multiply a vector by a scalar (scalar multiple). The operands for this function are not required to be enclosed in parentheses.
-: Negate a scalar or vector (unary minus), or subtract one scalar or vector from another. The operands for this function are not required to be enclosed in parentheses.
+: Add two scalars or two vectors. The operands for this function are not required to be enclosed in parentheses.
sin: Compute the sine of a scalar.
cos: Compute the cosine of a scalar.
tan: Compute the tangent of a scalar.
asin: Compute the arcsine of a scalar.
acos: Compute the arccosine of a scalar.
atan: Compute the arctangent of a scalar.
sinh: Compute the hyperbolic sine of a scalar.
cosh: Compute the hyperbolic cosine of a scalar.
tanh: Compute the hyperbolic tangent of a scalar.
x^y: Raise one scalar to the power of another scalar. The operands for this function are not required to be enclosed in parentheses.
sqrt: Compute the square root of a scalar.
e^x: Raise e to the power of a scalar.
log: Compute the logarithm of a scalar.
ceil: Compute the ceiling of a scalar.
floor: Compute the floor of a scalar.
abs: Compute the absolute value of a scalar.
v1.v2: Compute the dot product of two vectors. The operands for this function are not required to be enclosed in parentheses.
mag: Compute the magnitude of a vector.
norm: Normalize a vector.
The operands are described below.
The digits 0 - 9 and the decimal point are used to enter constant scalar values.
iHat, jHat, and kHat are vector constants representing unit vectors in the X, Y, and Z directions, respectively.
The scalars menu lists the names of the scalar arrays and the components of the vector arrays of either the point-centered or cell-centered data. The vectors menu lists the names of the point-centered or cell-centered vector arrays. The function will be computed for each point (or cell) using the scalar or vector value of the array at that point (or cell).
The filter operates on any type of data set, but the input data set must have at least one scalar or vector array. The arrays can be either point-centered or cell-centered. The Calculator filter's output is of the same data set type as the input.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            This property specifies the input dataset to the Calculator filter. The scalar and vector variables may be chosen from this dataset's arrays.
          </Documentation>
     </InputProperty>

     <Property
        name="RemoveAllVariables"
        command="RemoveAllVariables"
        immediate_update="1"
        is_internal="0"
        label="Clear">
        <Documentation>
          This property erases the current function from the calculator. (See the Function property.)
        </Documentation>
     </Property>

     <StringVectorProperty 
        name="ResultArrayName" 
        command="SetResultArrayName" 
        number_of_elements="1"
        default_values="Result">
        <Documentation>
          This property contains the name for the output array containing the result of this computation.
        </Documentation>
     </StringVectorProperty> 
     
     <StringVectorProperty 
        name="Function" 
        command="SetFunction" 
        number_of_elements="1">
        <Documentation>
          This property contains the equation for computing the new array.
        </Documentation>
     </StringVectorProperty>
   
     <StringVectorProperty 
        name="AddScalarVariable" 
        command="AddScalarVariable" 
        clean_command="RemoveScalarVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="3"
        element_types="2 2 0"
        label="Scalar Variable">
        <Documentation>
          This property adds a new scalar variable (single-component array or a single component of a multi-component array) to the current function for computing a new array.
        </Documentation>
     </StringVectorProperty>

     <StringVectorProperty 
        name="AddVectorVariable" 
        command="AddVectorVariable" 
        clean_command="RemoveVectorVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="5"
        element_types="2 2 0 0 0"
        label="Vector Variable">
        <Documentation>
          This property adds a new vector variable (multi-component array) to the current function for computing a new array.
        </Documentation>
     </StringVectorProperty>
     
     <StringVectorProperty 
        name="AddCoordinateScalarVariable" 
        command="AddCoordinateScalarVariable" 
        clean_command="RemoveCoordinateScalarVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="2"
        element_types="2 0"
        label="Coordinate Scalar Variable">
        <Documentation>
          This property adds a new scalar variable (single-component array or a single component of a multi-component array) to the current function for computing new point coordinates.
        </Documentation>
     </StringVectorProperty>

     <StringVectorProperty 
        name="AddCoordinateVectorVariable" 
        command="AddCoordinateVectorVariable" 
        clean_command="RemoveCoordinateVectorVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="4"
        element_types="2 0 0 0"
        label="Coordinate Vector Variable">
        <Documentation>
          This property adds a new vector variable (multi-component array) to the current function for computing new point coordinates.
        </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        name="CoordinateResults" 
        command="SetCoordinateResults" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property determines whether the results of this computation should be used as point coordinates or as a new array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="AttributeMode" 
        command="SetAttributeMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="1" text="point_data"/>
         <Entry value="2" text="cell_data"/>
       </EnumerationDomain>
       <Documentation>
         This property determines whether the computation is to be performed on point-centered or cell-centered data.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ReplaceInvalidValues" 
        label="Replace Invalid Results"
        command="SetReplaceInvalidValues" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         This property determines whether invalid values in the computation will be replaced with a specific value. (See the ReplacementValue property.)
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ReplacementValue"
        command="SetReplacementValue"
        number_of_elements="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If invalid values in the computation are to be replaced with another value, this property contains that value.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End Calculator -->
   </SourceProxy>

   <SourceProxy name="FeatureEdges" class="vtkFeatureEdges"
    label="Feature Edges">
    <Documentation
       long_help="This filter will extract edges along sharp edges of surfaces or boundaries of surfaces."
       short_help="Extract edges that meet the feature critera.">
The Feature Edges filter extracts various subsets of edges from the input data set. This filter operates on polygonal data and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Feature Edges filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="BoundaryEdges" 
        command="SetBoundaryEdges" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, boundary edges will be extracted. Boundary edges are defined as lines cells or edges that are used by only one polygon.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="FeatureEdges" 
        command="SetFeatureEdges" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, feature edges will be extracted. Feature edges are defined as edges that are used by two polygons whose dihedral angle is greater than the feature angle. (See the FeatureAngle property.)
         Toggle whether to extract feature edges.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="NonManifoldEdges" 
        command="SetNonManifoldEdges" 
        number_of_elements="1"
        default_values="1"
        label="Non-Manifold Edges"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, non-manifold ediges will be extracted. Non-manifold edges are defined as edges that are use by three or more polygons.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ManifoldEdges" 
        command="SetManifoldEdges" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, manifold edges will be extracted. Manifold edges are defined as edges that are used by exactly two polygons.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Coloring" 
        command="SetColoring" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, then the extracted edges are assigned a scalar value based on the type of the edge.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="30.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
       <Documentation>
         Ths value of this property is used to define a feature edge. If the surface normal between two adjacent triangles is at least as large as this Feature Angle, a feature edge exists. (See the FeatureEdges property.)
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End FeatureEdges -->
   </SourceProxy>

   <SourceProxy name="Gradient" class="vtkImageGradient" label="Gradient">
    <Documentation
      short_help="Compute gradient vectors."
      long_help="This filter computes gradient vectors for an image/volume.">
The Gradient filter computes the gradient vector at each point in an image or volume. This filter uses central differences to compute the gradients. The Gradient filter operates on uniform rectilinear (image) data and produces image data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" 
                            number_of_components="1"/>
          <Documentation>
            This property specifies the input to the Gradient filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property lists the name of the array from which to compute the gradient.
           </Documentation>
     </StringVectorProperty>
     <IntVectorProperty 
        name="Dimensionality" 
        command="SetDimensionality" 
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates whether to compute the gradient in two dimensions or in three. If the gradient is being computed in two dimensions, the X and Y dimensions are used.
       </Documentation>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

   <SourceProxy name="UnstructuredGradient" class="vtkGradientFilter"
     label="Gradient (Unstructured)">
     <Documentation
       short_help="Compute gradients for any type of dataset."
       long_help="Estimate the gradient for each point or cell in any type of dataset.">
The Gradient (Unstructured) filter estimates the gradient vector at each point or cell. It operates on any type of vtkDataSet, and the output is the same type as the input. If the dataset is a vtkImageData, use the Gradient filter instead; it will be more efficient for this type of dataset.
     </Documentation>
     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkPointSet"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array" number_of_components="1">
         <RequiredProperties>
           <Property name="SelectInputScalars" function="FieldDataSelection"/>
         </RequiredProperties>
       </InputArrayDomain>
       <Documentation>
         This property specifies the input to the Gradient (Unstructured) filter.
       </Documentation>
     </InputProperty>

     <StringVectorProperty name="SelectInputScalars"
                           command="SetInputArrayToProcess"
                           number_of_elements="5"
                           element_types="0 0 0 0 2"
                           label="Scalar Array">
       <ArrayListDomain name="array_list" attribute_type="Scalars">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <FieldDataDomain name="field_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         This property lists the name of the scalar array from which to compute the gradient.
       </Documentation>
     </StringVectorProperty>
     <StringVectorProperty name="ResultArrayName"
                           command="SetResultArrayName"
                           number_of_elements="1"
                           default_values="Gradients">
       <Documentation>
         This property provides a name for the output array containing the gradient vectors.
       </Documentation>
     </StringVectorProperty>
   <!-- End UnstructuredGradient -->
   </SourceProxy>

   <SourceProxy name="GradientMagnitude" class="vtkImageGradientMagnitude"
      label="Gradient Magnitude">
     <Documentation
       short_help="Compute the gradient magnitude."
       long_help="Compute the magnitude of the gradient vectors for an image/volume.">
The Gradient Magnitude filter computes the magnitude of the gradient vector at each point in an image or volume. This filter operates on uniform rectilinear (image) data and produces image data output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkImageData"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point" 
                             number_of_components="1"/>
           <Documentation>
             This property specifies the input to the Gradient Magnitude filter.
           </Documentation>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property lists the name of the scalar array to use in computing the gradient magnitude.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        name="Dimensionality" 
        command="SetDimensionality" 
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates whether to compute the gradient magnitude in two or three dimensions. If computing the gradient magnitude in 2D, the gradients in X and Y are used for computing the gradient magnitude.
       </Documentation>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

   <SourceProxy name="LinearExtrusionFilter" class="vtkPVLinearExtrusionFilter"
    label="Linear Extrusion">
    <Documentation
       long_help="This filter creates a swept surface defined by translating the input along a vector."
       short_help="Generate a linear swept surface.">
The Linear Extrusion filter creates a swept surface by translating the input dataset along a specified vector. This filter is intended to operate on 2D polygonal data. This filter operates on polygonal data and produces polygonal data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Linear Extrusion filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property determines the distance along the vector the dataset will be translated. (A scale factor of 0.5 will move the dataset half the length of the vector, and a scale factor of 2 will move it twice the vector's length.)
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Vector"
        command="SetVector"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property indicates the X, Y, and Z components of the vector along which to sweep the input dataset.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property indicates whether to cap the ends of the swept surface. Capping works by placing a copy of the input dataset on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input dataset is a closed solid (e.g., a sphere), then if capping is on (i.e., this property is set to 1), two copies of the data set will be displayed on output (the second translated from the first one along the specified vector). If instead capping is off (i.e., this property is set to 0), then an input closed solid will produce no output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property determines whether the output will be the same regardless of the number of processors used to compute the result. The difference is whether there are internal polygonal faces on the processor boundaries. A value of 1 will keep the results the same; a value of 0 will allow internal faces on processor boundaries.
       </Documentation>
     </IntVectorProperty>
   <!-- End LinearExtrusionFilter -->
   </SourceProxy>

   <SourceProxy name="LoopSubdivisionFilter" class="vtkLoopSubdivisionFilter"
    label="Loop Subdivision">
    <Documentation
       long_help="This filter iteratively divides each triangle into four triangles.  New points are placed so the output surface is smooth."
       short_help="Create a higher resolution and smoother surface.">
The Loop Subdivision filter increases the granularity of a polygonal mesh. It works by dividing each triangle in the input into four new triangles. It is named for Charles Loop, the person who devised this subdivision scheme. This filter only operates on triangles, so a data set that contains other types of polygons should be passed through the Triangulate filter before applying this filter to it. This filter only operates on polygonal data (specifically triangle meshes), and it produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Loop Subdivision filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSubdivisions" 
        command="SetNumberOfSubdivisions" 
        number_of_elements="1"
        animateable="1"
        default_values="1"
        label="Number of Subdivisions"> 
       <IntRangeDomain name="range" min="1" max="4"/>
       <Documentation>
         Set the number of subdivision iterations to perform. Each subdivision divides single triangles into four new triangles.
       </Documentation>
     </IntVectorProperty>
   <!-- End LoopSubdivisionFilter -->
   </SourceProxy>

   <SourceProxy name="MaskPoints" class="vtkMaskPoints"
    label="Mask Points">
    <Documentation
          long_help="Reduce the number of points.  This filter is often used before glyphing. Generating vertices is an option."
          short_help="Reduce the number of points.">
The Mask Points filter reduces the number of points in the dataset. It operates on any type of dataset, but produces only points / vertices as output. This filter is often used before the Glyph filter, but the basic point-masking functionality is also available on the Properties page for the Glyph filter.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Mask Points filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="OnRatio" 
        command="SetOnRatio" 
        number_of_elements="1"
        default_values="2" > 
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         The value of this property specifies the ratio of points to retain in the output. (For example, if the on ratio is 3, then the output will contain 1/3 as many points -- up to the value of the MaximumNumberOfPoints property -- as the input.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfPoints" 
        command="SetMaximumNumberOfPoints" 
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points"> 
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property indicates the maximum number of points in the output dataset.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Offset" 
        command="SetOffset" 
        number_of_elements="1"
        animateable="1"
        default_values="0" > 
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property indicates the point in the input dataset from which to start masking.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="0"
        label="Random"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 0, then the points in the output will be randomly selected from the input; otherwise this filter will subsample regularly. Selecting points at random is helpful to avoid striping when masking the points of a structured dataset.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="GenerateVertices" 
        command="SetGenerateVertices" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         This property specifies whether to generate vertex cells as the topography of the output. If set to 1, the geometry (vertices) will be displayed in the rendering window; otherwise no geometry will be displayed.
       </Documentation>
     </IntVectorProperty>
   <!-- End MaskPoints -->
   </SourceProxy>

   <SourceProxy name="Median" class="vtkImageMedian3D">
    <Documentation
      short_help="Compute median values in a given neighborhood."
      long_help="Compute the median scalar values in a specified neighborhood for image/volume datasets.">
The Median filter operates on uniform rectilinear (image or volume) data and produces uniform rectilinear output. It replaces the scalar value at each pixel / voxel with the median scalar value in the specified surrounding neighborhood. Since the median operation removes outliers, this filter is useful for removing high-intensity, low-probability noise (shot noise).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" 
                            number_of_components="1"/>
          <Documentation>
            This property specifies the input to the Median filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             The value of thie property lists the name of the scalar array to use in computing the median.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        name="KernelSize" 
        command="SetKernelSize" 
        number_of_elements="3"
        default_values="1 1 1" > 
       <IntRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the number of pixels/voxels in each dimension to use in computing the median to assign to each pixel/voxel. If the kernel size in a particular dimension is 1, then the median will not be computed in that direction.
       </Documentation>
     </IntVectorProperty>
   <!-- End Median -->
   </SourceProxy>

   <SourceProxy name="MeshQuality" class="vtkMeshQuality"
    label="Mesh Quality">
    <Documentation
       long_help="This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes."
       short_help="Evaluate geometric mesh quality.">
This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes. Supported shapes include triangles, quadrilaterals, tetrahedra, and hexahedra. For other shapes, a value of 0 is assigned.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Mesh Quality filter.
          </Documentation>
     </InputProperty>
     <IntVectorProperty
        name="TriangleQualityMeasure"
        command="SetTriangleQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="28" text="Area"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="8" text="Maximum Angle"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate triangle quality. The radius ratio is the size of a circle circumscribed by a triangle's 3 vertices divided by the size of a circle tangent to a triangle's 3 edges. The edge ratio is the ratio of the longest edge length to the shortest edge length.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="QuadQualityMeasure"
        command="SetQuadQualityMeasure"
        number_of_elements="1"
        default_values="0">
       <EnumerationDomain name="enum">
         <Entry value="28" text="Area"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="16" text="Maximum Edge Ratio"/>
         <Entry value="4" text="Mean Aspect Frobenius"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="11" text="Shear"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="17" text="Skew"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="18" text="Taper"/>
         <Entry value="26" text="Warpage"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate quadrilateral quality.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="TetQualityMeasure"
        command="SetTetQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="29" text="Aspect Beta"/>
         <Entry value="27" text="Aspect Gamma"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="7" text="Collapse Ratio"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="6" text="Minimum Dihedral Angle"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="19" text="Volume"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate tetrahedral quality. The radius ratio is the size of a sphere circumscribed by a tetrahedron's 4 vertices divided by the size of a circle tangent to a tetrahedron's 4 faces. The edge ratio is the ratio of the longest edge length to the shortest edge length. The collapse ratio is the minimum ratio of height of a vertex above the triangle opposite it divided by the longest edge of the opposing triangle across all vertex/triangle pairs.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="HexQualityMeasure"
        command="SetHexQualityMeasure"
        number_of_elements="1"
        default_values="5">
       <EnumerationDomain name="enum">
         <Entry value="21" text="Diagonal"/> 
         <Entry value="22" text="Dimension"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="16" text="Maximum Edge Ratio"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="4" text="Mean Aspect Frobenius"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="11" text="Shear"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="17" text="Skew"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="18" text="Taper"/>
         <Entry value="19" text="Volume"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate hexahedral quality.
       </Documentation>
     </IntVectorProperty>
   <!-- End MeshQuality -->
   </SourceProxy>

   <SourceProxy name="PolyDataNormals" class="vtkPPolyDataNormals"
    label="Normals Generation">
    <Documentation
       long_help="This filter will produce surface normals used for smooth shading. Spltting is used to avoid smoothing across feature edges."
       short_help="Produce surface point normals.">
The Normals generation filter generates surface normals at the points of the input polygonal dataset to provide smooth shading of the dataset. The resulting dataset is also polygonal. The filter works by calculating a normal vector for each polygon in the dataset and then averaging the normals at the shared points.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Normals Generation filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty 
        name="FeatureAngle" 
        command="SetFeatureAngle" 
        number_of_elements="1"
        default_values="30" > 
       <DoubleRangeDomain name="range" min="0" max="180"/>
       <Documentation>
         The value of this property  defines a feature edge. If the surface normal between two adjacent triangles is at least as large as this Feature Angle, a feature edge exists. If Splitting is on, points are duplicated along these feature edges. (See the Splitting property.)
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="Splitting" 
        command="SetSplitting" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         This property controls the splitting of sharp edges. If sharp edges are split (property value = 1), then points are duplicated along these edges, and separate normals are computed for both sets of points to give crisp (rendered) surface definition.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Consistency" 
        command="SetConsistency" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property controls whether consistent polygon ordering is enforced. Generally the normals for a data set should either all point inward or all point outward. If the value of this property is 1, then this filter will reorder the points of cells that whose normal vectors are oriented the opposite direction from the rest of those in the data set.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="FlipNormals" 
        command="SetFlipNormals" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, this filter will reverse the normal direction (and reorder the points accordingly) for all polygons in the data set; this changes front-facing polygons to back-facing ones, and vice versa. You might want to do this if your viewing position will be inside the data set instead of outside of it.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="NonManifoldTraversal" 
        command="SetNonManifoldTraversal" 
        number_of_elements="1"
        default_values="1"
        label="Non-Manifold Traversal"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off traversal across non-manifold edges. Not traversing non-manifold edges will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeCellNormals" 
        command="SetComputeCellNormals" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         This filter computes the normals at the points in the data set. In the process of doing this it computes polygon normals too. If you want these normals to be passed to the output of this filter, set the value of this property to 1.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn this option to to produce the same results regardless of the number of processors used (i.e., avoid seams along processor boundaries). Turn this off if you do want to process ghost levels and do not mind seams.
       </Documentation>
     </IntVectorProperty>
   <!-- End  PolyDataNormals -->
   </SourceProxy>

   <SourceProxy name="OutlineFilter" class="vtkPOutlineFilter"
     label="Outline">
     <Documentation
        long_help="This filter generates a bounding box representation of the input."
        short_help="Generates a bounding box.">
The Outline filter generates an axis-aligned bounding box for the input dataset. This filter operates on any type of dataset and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Outline filter.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End  OutlineFilter -->
   </SourceProxy>

   <SourceProxy name="OutlineCornerFilter" class="vtkPOutlineCornerFilter"
    label="Outline Corners">
    <Documentation
       long_help="This filter generates a bounding box representation of the input. It only displays the corners of the bounding box."
       short_help="Generates corners of a bounding box.">
The Outline Corners filter generates the corners of a bounding box for the input dataset. This filter operates on any type of dataset and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Outline Corners filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="CornerFactor"
        command="SetCornerFactor"
        number_of_elements="1"
        default_values="0.2" >
       <DoubleRangeDomain name="range" min="0.001" max="0.5" />
       <Documentation>
         The value of this property sets the size of the corners as a percentage of the length of the corresponding bounding box edge.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  OutlineCornerFilter -->
   </SourceProxy>

   <SourceProxy name="OctreeDepthScalars" class="vtkHyperOctreeDepth"
     label="Octree Depth Scalars">
     <Documentation
        long_help="This filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree."
        short_help="Computes cell depths within the octree.">
The vtkHyperOctreeDepth filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Octree Depth Scalars filter.
           </Documentation>
      </InputProperty>
   <!-- End  OctreeDepthScalars-->
   </SourceProxy>

   <SourceProxy name="OctreeDepthLimit" class="vtkHyperOctreeLimiter"
     label="Octree Depth Limit">
     <Documentation
        long_help="This filter takes in a octree and produces a new octree which is no deeper than the maximum specified depth level."
        short_help="Reduce an octree's resolution.">
The Octree Depth Limit filter takes in an octree and produces a new octree that is nowhere deeper than the maximum specified depth level. The attribute data of pruned leaf cells are integrated in to their ancestors at the cut level.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Octree Depth Limit filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        name="MaximumLevel" 
        command="SetMaximumLevel" 
        number_of_elements="1"
        default_values="4" > 
       <IntRangeDomain name="range" min="3" max="255"/>
       <Documentation>
         The value of this property specifies the maximum depth of the output octree.
       </Documentation>
     </IntVectorProperty>
   <!-- End  OctreeDepthLimit-->
   </SourceProxy>

   <SourceProxy name="ProcessIdScalars" class="vtkProcessIdScalars"
                label="Process Id Scalars"
                multiprocess_support="multiple_processes">
     <Documentation
        long_help="This filter uses colors to show how data is partitioned across processes."
        short_help="Generate point scalars from process id.">
The Process Id Scalars filter assigns a unique scalar value to each piece of the input according to which processor it resides on. This filter operates on any type of data when ParaView is run in parallel. It is useful for determining whether your data is load-balanced across the processors being used. The output data set type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Process Id Scalars filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property determines whether to use random id values for the various pieces. If set to 1, the unique value per piece will be chosen at random; otherwise the unique value will match the id of the process.
       </Documentation>
     </IntVectorProperty>
   <!-- End PieceScalars -->
   </SourceProxy>

   <SourceProxy name="PointDataToCellData" class="vtkPointDataToCellData"
     label="Point Data to Cell Data">
     <Documentation
        long_help="Create cell attributes by averaging point attributes."
        short_help="Convert point data to cell data.">
The Point Data to Cell Data filter averages the values of the point attributes of the points of a cell to compute cell attributes. This filter operates on any type of dataset, and the output dataset is the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"/>
           <FixedTypeDomain name="fixed_type"/>
           <Documentation>
             This property specifies the input to the Point Data to Cell Data filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        name="PassPointData" 
        command="SetPassPointData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property controls whether the input point data will be passed to the output. If set to 1, then the input point data is passed through to the output; otherwise, only generated cell data is placed into the output.
       </Documentation>
     </IntVectorProperty>
   <!-- End PointDataToCellData -->
   </SourceProxy>

   <SourceProxy name="QuadricClustering" class="vtkQuadricClustering"
    label="Quadric Clustering">
    <Documentation
       long_help="This filter is the same filter used to generate level of detail for ParaView.  It uses a structured grid of bins and merges all points contained in each bin."
       short_help="Simplify polygonal models.">
The Quadric Clustering filter produces a reduced-resolution polygonal approximation of the input polygonal dataset. This filter is the one used by ParaView for computing LODs. It uses spatial binning to reduce the number of points in the data set; points that lie within the same spatial bin are collapsed into one representative point.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Quadric Clustering filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfDivisions" 
        command="SetNumberOfDivisions" 
        number_of_elements="3"
        default_values="50 50 50"
        label="Number of Dimensions" > 
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the number of bins along the X, Y, and Z axes of the data set.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseInputPoints" 
        command="SetUseInputPoints" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, the representative point for each bin is selected from one of the input points that lies in that bin; the input point that produces the least error is chosen. If the value of this property is 0, the location of the representative point is calculated to produce the least error possible for that bin, but the point will most likely not be one of the input points.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseFeatureEdges" 
        command="SetUseFeatureEdges" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, feature edge quadrics will be used to maintain the boundary edges along processor divisions.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseFeaturePoints" 
        command="SetUseFeaturePoints" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, feature point quadrics will be used to maintain the boundary points along processor divisions.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="CopyCellData" 
        command="SetCopyCellData" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the cell data from the input will be copied to the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseInternalTriangles"
        command="SetUseInternalTriangles"
        number_of_elements="1"
        default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, triangles completely contained in a spatial bin will be included in the computation of the bin's quadrics. When this property is set to 0, the filters operates faster, but the resulting surface may not be as well-behaved.
       </Documentation>
     </IntVectorProperty>
   <!-- End QuadricClustering -->
   </SourceProxy>

   <SourceProxy name="BrownianPoints" class="vtkBrownianPoints" label="Random Vectors">
    <Documentation
       long_help="This filter creates a new 3-component point data array and sets it as the default vector array. It uses a random number generator to create values."
       short_help="Create a new random vector array.">
The Random Vectors filter generates a point-centered array of random vectors. It uses a random number generator to determine the components of the vectors. This filter operates on any type of data set, and the output data set will be of the same type as the input.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Random Vectors filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty 
        name="MinimumSpeed" 
        command="SetMinimumSpeed" 
        number_of_elements="1"
        default_values="0" > 
       <DoubleRangeDomain name="range" min="0" />
       <Documentation>
         This property specifies the minimum length of the random point vectors generated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty 
        name="MaximumSpeed" 
        command="SetMaximumSpeed" 
        number_of_elements="1"
        default_values="1" > 
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         This property specifies the maximum length of the random point vectors generated.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End BrownianPoints -->
   </SourceProxy>

   <SourceProxy name="ReflectionFilter" class="vtkReflectionFilter" 
    label="Reflect">
    <Documentation
       long_help="This filter takes the union of the input and its reflection over an axis-aligned plane."
       short_help="Reflect input over an axis aligned plane.">
The Reflect filter reflects the input dataset across the specified plane. This filter operates on any type of data set and produces an unstructured grid output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Reflect filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="Plane" 
        command="SetPlane" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="X Min"/>
         <Entry value="1" text="Y Min"/>
         <Entry value="2" text="Z Min"/>
         <Entry value="3" text="X Max"/>
         <Entry value="4" text="Y Max"/>
         <Entry value="5" text="Z Max"/>
         <Entry value="6" text="X"/>
         <Entry value="7" text="Y"/>
         <Entry value="8" text="Z"/>
       </EnumerationDomain>
       <Documentation>
         The value of this property determines which plane to reflect across. If the value is X, Y, or Z, the value of the Center property determines where the plane is placed along the specified axis. The other six options (X Min, X Max, etc.) place the reflection plane at the specified face of the bounding box of the input dataset.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Center"
        command="SetCenter"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If the value of the Plane property is X, Y, or Z, then the value of this property specifies the center of the reflection plane.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="CopyInput"
        command="SetCopyInput"
        number_of_elements="1"
        default_values="1">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the output will contain the union of the input dataset and its reflection. Otherwise the output will contain only the reflection of the input data.
       </Documentation>
     </IntVectorProperty>
   <!-- End ReflectionFilter -->
   </SourceProxy>

   <SourceProxy name="RibbonFilter" class="vtkRibbonFilter"
    label="Ribbon">
    <Documentation
       long_help="This filter generates ribbon surface from lines.  It is useful for displaying streamlines."
       short_help="Create ribbon surfaces from lines.">
The Ribbon filter creates ribbons from the lines in the input data set. This filter is useful for visualizing streamlines. Both the input and output of this filter are polygonal data. The input data set must also have at least one point-centered vector array.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <Documentation>
            This property specifies the input to the Ribbon filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars"
                            input_domain_name="input_array2">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             The value of this property indicates the name of the input scalar array used by this filter. The width of the ribbons will be varied based on the values in the specified array if the value of the Width property is 1.
           </Documentation>
     </StringVectorProperty> 

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1"
        label="Vectors"> <!-- default_values=1, send vectors to the right place -->
           <ArrayListDomain name="array_list" attribute_type="Vectors"
                            input_domain_name="input_array1">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             The value of this property indicates the name of the input vector array used by this filter. If the UseDefaultNormal property is set to 0, the normal vectors for the ribbons come from the specified vector array.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="Width"
        command="SetWidth"
        number_of_elements="1"
        default_values="1" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         If the VaryWidth property is set to 1, the value of this property is the minimum ribbon width. If the VaryWidth property is set to 0, the value of this property is half the width of the ribbon.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range" min="0" max="360" />
       <Documentation>
         The value of this property specifies the offset angle (in degrees) of the ribbon from the line normal.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="UseDefaultNormal" 
        command="SetUseDefaultNormal" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 0, and the input contains no vector array, then default ribbon normals will be generated (DefaultNormal property); if a vector array has been set (SelectInputVectors property), the ribbon normals will be set from the specified array. If this property is set to 1, the default normal (DefaultNormal property) will be used, regardless of whether the SelectInputVectors property has been set.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="DefaultNormal"
        command="SetDefaultNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the normal to use when the UseDefaultNormal property is set to 1 or the input contains no vector array (SelectInputVectors property).
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="VaryWidth" 
        command="SetVaryWidth" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the ribbon width will be scaled according to the scalar array specified in the SelectInputScalars property.
         Toggle the variation of ribbon width with scalar value.
       </Documentation>
     </IntVectorProperty>
   <!-- End RibbonFilter -->
   </SourceProxy>

   <SourceProxy name="RotationalExtrusionFilter" 
                class="vtkRotationalExtrusionFilter"
                label="Rotational Extrusion">
    <Documentation
       long_help="This filter generates a swept surface while translating the input along a circular path."
       short_help="Generates a swept surface using a rotational path.">
The Rotational Extrusion filter forms a surface by rotating the input about the Z axis. This filter is intended to operate on 2D polygonal data. It produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Rotational Extrusion filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="Resolution" 
        command="SetResolution" 
        number_of_elements="1"
        default_values="12" > 
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         The value of this property controls the number of intermediate node points used in performing the sweep (rotating from 0 degrees to the value specified by the Angle property.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the open ends of the swept surface will be capped with a copy of the input dataset. This works property if the input is a 2D surface composed of filled polygons. If the input dataset is a closed solid (e.g., a sphere), then either two copies of the dataset will be drawn or no surface will be drawn. No surface is drawn if either this property is set to 0 or if the two surfaces would occupy exactly the same 3D space (i.e., the Angle property's value is a multiple of 360, and the values of the Translation and DeltaRadius properties are 0).
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        animateable="1"
        default_values="360" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the angle of rotation in degrees. The surface is swept from 0 to the value of this property.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Translation"
        command="SetTranslation"
        number_of_elements="1"
        animateable="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the total amount of translation along the Z axis during the sweep process. Specifying a non-zero value for this property allows you to create a corkscrew (value of DeltaRadius > 0) or spring effect.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="DeltaRadius"
        command="SetDeltaRadius"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the change in radius during the sweep process.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End RotationalExtrusionFilter -->
   </SourceProxy>

   <SourceProxy name="ShrinkFilter" class="vtkShrinkFilter"
                label="Shrink">
     <Documentation
        long_help="This filter shrinks each input cell so they pull away from their neighbors."
        short_help="Shrink each input cell.">
The Shrink filter causes the individual cells of a dataset to break apart from each other by moving each cell's points toward the centroid of the cell. (The centroid of a cell is the average position of its points.) This filter operates on any type of dataset and produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Shrink filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="ShrinkFactor"
         command="SetShrinkFactor"
         number_of_elements="1"
         animateable="1"
         default_values="0.5" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          The value of this property determines how far the points will move. A value of 0 positions the points at the centroid of the cell; a value of 1 leaves them at their original positions.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End ShrinkFilter -->
   </SourceProxy>

   <SourceProxy name="SmoothPolyDataFilter" class="vtkSmoothPolyDataFilter"
    label="Smooth">
    <Documentation
       long_help="This filter smooths a polygonal surface by iteratively moving points toward their neighbors."
       short_help="Smooth a polygonal surface without adding more points.">
The Smooth filter operates on a polygonal data set by iteratively adjusting the position of the points using Laplacian smoothing. (Because this filter only adjusts point positions, the output data set is also polygonal.) This results in better-shaped cells and more evenly distributed points.

The Convergence slider limits the maximum motion of any point. It is expressed as a fraction of the length of the diagonal of the bounding box of the data set. If the maximum point motion during a smoothing iteration is less than the Convergence value, the smoothing operation terminates.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Smooth filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfIterations" 
        command="SetNumberOfIterations" 
        number_of_elements="1"
        animateable="1"
        default_values="20"
        label="Number of Iterations"> 
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         This property sets the maximum number of smoothing iterations to perform. More iterations produce better smoothing.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Convergence"
         command="SetConvergence"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          The value of this property limits the maximum motion of any point. It is expressed as a fraction of the length of the diagonal of the bounding box of the input dataset. If the maximum point motion during a smoothing iteration is less than the value of this property, the smoothing operation terminates.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End SmoothPolyDataFilter -->
   </SourceProxy>

   <SourceProxy name="Stripper" class="vtkStripper"
    label="Triangle Strips">
    <Documentation
       long_help="This filter uses a greedy algorithm to convert triangles into triangle strips"
       short_help="Convert triangles into triangle strips.">
The Triangle Strips filter converts triangles into triangle strips and lines into polylines. This filter operates on polygonal data sets and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Triangle Strips filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="MaximumLength" 
        command="SetMaximumLength" 
        number_of_elements="1"
        default_values="1000" > 
       <IntRangeDomain name="range" min="4" max="100000"/>
       <Documentation>
         This property specifies the maximum number of triangles/lines to include in a triangle strip or polyline.
       </Documentation>
     </IntVectorProperty>
   <!-- End Stripper -->
   </SourceProxy>

   <SourceProxy name="Subdivide" class="vtkLinearSubdivisionFilter">
    <Documentation
       long_help="This filter iteratively divide triangles into four smaller triangles.  New points are placed linearly so the output surface matches the input surface."
       short_help="Creates a surface with more triangles than the input.">
The Subdivide filter iteratively divides each triangle in the input dataset into 4 new triangles. Three new points are added per triangle -- one at the midpoint of each edge. This filter operates only on polygonal data containing triangles, so run your polygonal data through the Triangulate filter first if it is not composed of triangles. The output of this filter is also polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This parameter specifies the input to the Subdivide filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSubdivisions" 
        command="SetNumberOfSubdivisions" 
        number_of_elements="1"
        default_values="1"
        label="Number of Subdivisions"> 
       <IntRangeDomain name="range" min="1" max="4"/>
       <Documentation>
         The value of this property specifies the number of subdivision iterations to perform.
       </Documentation>
     </IntVectorProperty>
   <!-- End Subdivide -->
   </SourceProxy>

   <SourceProxy name="TessellatorFilter" class="vtkTessellatorFilter" 
     label="Tessellate">
     <Documentation
        long_help="Tessellate nonlinear curves, surfaces, and volumes with lines, triangles, and tetrahedra."
        short_help="Polygonalize a mesh.">
The Tessellate filter tessellates cells with nonlinear geometry and/or scalar fields into a simplicial complex with linearly interpolated field values that more closely approximate the original field. This is useful for datasets containing quadratic cells.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
             <DataType value="vtkDataSet"/>
             <DataType value="vtkUnstructuredGrid"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Tessellate filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="OutputDimension"
        command="SetOutputDimension"
        number_of_elements="1"
        default_values="3">
       <IntRangeDomain name="range" min="1" max="3"/>
       <Documentation>
         The value of this property sets the maximum dimensionality of the output tessellation. When the value of this property is 3, 3D cells produce tetrahedra, 2D cells produce triangles, and 1D cells produce line segments. When the value is 2, 3D cells will have their boundaries tessellated with triangles. When the value is 1, all cells except points produce line segments.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ChordError"
        command="SetChordError"
        number_of_elements="1"
        default_values="1e-3">
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property controls the maximum chord error allowed at any edge midpoint in the output tessellation. The chord error is measured as the distance between the midpoint of any output edge and the original nonlinear geometry.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="FieldError2"
        command="SetFieldCriterion"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        label="Field Error">
        <Documentation>
          This proeprty controls the maximum field error allowed at any edge midpoint in the output tessellation. The field error is measured as the difference between a field value at the midpoint of an output edge and the value of the corresponding field in the original nonlinear geometry.
        </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MaximumNumberOfSubdivisions"
        command="SetMaximumNumberOfSubdivisions"
        number_of_elements="1"
        default_values="3"
        label="Maximum Number of Subdivisions">
       <IntRangeDomain name="range" min="0" max="8"/>
       <Documentation>
         This property specifies the maximum number of times an edge may be subdivided. Increasing this number allows further refinement but can drastically increase the computational and storage requirements, especially when the value of the OutputDimension property is 3.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="MergePoints" 
        command="SetMergePoints" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, coincident vertices will be merged after tessellation has occurred. Only geometry is considered during the merge and the first vertex encountered is the one whose point attributes will be used. Any discontinuities in point fields will be lost. On the other hand, many operations, such as streamline generation, require coincident vertices to be merged.
         Toggle whether to merge coincident vertices.
       </Documentation>
     </IntVectorProperty>

     <Property
        name="ResetFieldCriteria"
        command="ResetFieldCriteria"
        immediate_update="1">
     </Property>
   <!-- End TessellatorFilter -->
   </SourceProxy>

   <SourceProxy name="DataSetTriangleFilter" class="vtkDataSetTriangleFilter"
     label="Tetrahedralize">
     <Documentation
        long_help="This filter converts 3-d cells to tetrahedrons and polygons to triangles.  The output is always of type unstructured grid."
        short_help="Convert to tetrahedrons and triangles.">
The Tetrahedralize filter converts the 3D cells of any type of dataset to tetrahedrons and the 2D ones to triangles. This filter always produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Tetrahedralize filter.
           </Documentation>
      </InputProperty>
   <!-- End DataSetTriangleFilter -->
   </SourceProxy>

   <SourceProxy name="TransformFilter" class="vtkTransformFilter"
    label="Transform">
    <Documentation
       long_help="This filter applies transformation to the polygons."
       short_help="Transform polygonal data.">
The Transform filter allows you to specify the position, size, and orientation of polygonal, unstructured grid, and curvilinear data sets.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPointSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Transform filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="Transform" command="SetTransform">
           <ProxyGroupDomain name="groups">
              <Group name="transforms"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <!-- Eventually, this transform will flaunt a 3D widget -->
              <Proxy group="transforms" name="Transform2" />
           </ProxyListDomain>
           <Documentation>
             The values in this property allow you to specify the transform (translation, rotation, and scaling) to apply to the input dataset.
           </Documentation>
     </ProxyProperty>
   <!-- End TransformFilter -->
   </SourceProxy>

   <SourceProxy name="TriangleFilter" class="vtkTriangleFilter"
     label="Triangulate">
     <Documentation
        long_help="This filter converts polygons and triangle strips to basic triangles."
        short_help="Convert polygonal data to triangles.">
The Triangulate filter decomposes polygonal data into only triangles, points, and lines. It separates triangle strips and polylines into individual triangles and lines, respectively. The output is polygonal data. Some filters that take polygonal data as input require that the data be composed of triangles rather than other polygons, so passing your data through this filter first is useful in such situations. You should use this filter in these cases rather than the Tetrahedralize filter because they produce different output dataset types. The filters referenced require polygonal input, and the Tetrahedralize filter produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Triangulate filter.
           </Documentation>
      </InputProperty>
   <!-- End TriangleFilter -->
   </SourceProxy>

   <SourceProxy name="TubeFilter" class="vtkTubeFilter" label="Tube">
    <Documentation
       long_help="Convert lines into tubes. Normals are used to avoid cracks between tube segments."
       short_help="Convert lines into tubes.">
The Tube filter creates tubes around the lines in the input polygonal dataset. The output is also polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Tube filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSides" 
        command="SetNumberOfSides" 
        number_of_elements="1"
        animateable="1"
        default_values="6"
        label="Number of Sides"> 
       <IntRangeDomain name="range" min="3"/>
       <Documentation>
         The value of this property indicates the number of faces around the circumference of the tube.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, endcaps will be drawn on the tube. Otherwise the ends of the tube will be open.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Radius"
         command="SetRadius"
         number_of_elements="1"
         default_values="1.0" >
        <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          The value of this property sets the radius of the tube. If the radius is varying (VaryRadius property), then this value is the minimum radius.
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="VaryRadius" 
        command="SetVaryRadius" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="By Scalar"/>
         <Entry value="2" text="By Vector"/>
       </EnumerationDomain>
       <Documentation>
         The property determines whether/how to vary the radius of the tube. If varying by scalar (1), the tube radius is based on the point-based scalar values in the dataset. If it is varied by vector, the vector magnitude is used in varying the radius.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="RadiusFactor"
         command="SetRadiusFactor"
         number_of_elements="1"
         default_values="10" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          If varying the radius (VaryRadius property), the property sets the maximum tube radius in terms of a multiple of the minimum radius. If not varying the radius, this value has no effect.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End TubeFilter -->
   </SourceProxy>

   <SourceProxy name="WarpScalar" class="vtkWarpScalar" label="Warp (scalar)">
     <Documentation
        long_help="This filter moves point coordinates along a vector scaled by a point attribute.  It can be used to produce carpet plots."
        short_help="Warp point scalars into a spatial elevation plot.">
The Warp (scalar) filter translates the points of the input data set along a vector by a distance determined by the specified scalars. This filter operates on polygonal, curvilinear, and unstructured grid data sets containing single-component scalar arrays. Because it only changes the positions of the points, the output data set type is the same as that of the input. Any scalars in the input dataset are copied to the output, so the data can be colored by them.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="1"/>
           <Documentation>
             This property specifies the input to the Warp (scalar) filter.
           </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the scalar array by which to warp the dataset.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The scalar value at a given point is multiplied by the value of this property to determine the magnitude of the change vector for that point.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Normal"
        command="SetNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The values of this property specify the direction along which to warp the dataset if any normals contained in the input dataset are not being used for this purpose. (See the UseNormal property.)
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="UseNormal" 
        command="SetUseNormal" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If point normals are present in the dataset, the value of this property toggles whether to use a single normal value (value = 1) or the normals from the dataset (value = 0).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="XYPlane" 
        command="SetXYPlane" 
        number_of_elements="1"
        default_values="0"
        label="XY Plane">
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then the Z-coordinates from the input are considered to be the scalar values, and the displacement is along the Z axis. This is useful for creating carpet plots.
       </Documentation>
     </IntVectorProperty>
   <!-- End WarpScalar -->
   </SourceProxy>

   <SourceProxy name="WarpVector" class="vtkWarpVector" label="Warp (vector)">
     <Documentation
        long_help="This filter displaces point coordinates along a vector attribute. It is useful for showing mechanical deformation."
        short_help="Warp (displace) the geometry with a given vector field.">
The Warp (vector) filter translates the points of the input dataset using a specified vector array. The vector array chosen specifies a vector per point in the input. Each point is translated along its vector by a given scale factor. This filter operates on polygonal, curvilinear, and unstructured grid datasets. Because this filter only changes the positions of the points, the output dataset type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Warp (vector) filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Vectors">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              The value of this property contains the name of the vector array by which to warp the dataset's point coordinates.
            </Documentation>
      </StringVectorProperty> 

      <DoubleVectorProperty
         name="ScaleFactor"
         command="SetScaleFactor"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Each component of the selected vector array will be multiplied by the value of this property before being used to compute new point coordinates.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End WarpVector -->
   </SourceProxy>

   <SourceProxy name="Cut" class="vtkCutter" label="Slice">
    <Documentation
       long_help="This filter slices a data set with a plane. Slicing is similar to a contour. It creates surfaces from volumes and lines from surfaces."
       short_help="Slice datasets with planes.">
This filter extracts the portion of the input dataset that lies along the specified plane. The Slice filter takes any type of dataset as input. The output of this filter is polygonal data.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Slice filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Slice Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             This property sets the parameters of the slice function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1"
        label="Slice Offset Values">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
          <Documentation>
            The values in this property specify a list of current offset values. This can be used to create multiple slices with different centers. Each entry represents a new slice with its center shifted by the offset value.
          </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End Cut -->
   </SourceProxy>

   <SourceProxy name="ExtractGeometry" class="vtkExtractGeometry" 
                label="Extract Cells by Region">
    <Documentation
       long_help="This filter extracts cells that are inside/outside a region or at a region boundary."
       short_help="Extract cells that are inside/outside a region or at a region boundary.">
This filter extracts from its input dataset all cells that are either completely inside or outside of a specified region (implicit function). On output, the filter generates an unstructured grid.
To use this filter you must specify a region  (implicit function). You must also specify whethter to extract cells lying inside or outside of the region. An option exists to extract cells that are neither inside or outside (i.e., boundary).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Slice filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ImplicitFunction" command="SetImplicitFunction"
                    label="Intersect With">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             This property sets the region used to extract cells.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        label="Extraction Side"
        name="ExtractInside" 
        command="SetExtractInside" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="outside"/>
         <Entry value="1" text="inside"/>
       </EnumerationDomain>
       <Documentation>
This parameter controls whether to extract cells that are inside or outside the region. 
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Extract only intersected" 
        command="SetExtractOnlyBoundaryCells" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
This parameter controls whether to extract only cells that are on the boundary of the region. If this parameter is set, the Extraction Side parameter is ignored. If Extract Intersected is off, this parameter has no effect.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Extract intersected" 
        command="SetExtractBoundaryCells" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
This parameter controls whether to extract cells that are on the boundary of the region. 
       </Documentation>
     </IntVectorProperty>

   <!-- End ExtractGeometry -->
   </SourceProxy>

   <SourceProxy name="Clip" class="vtkPVClipDataSet">
    <Documentation
       long_help="Clip with an implicit plane. Clipping does not reduce the dimensionality of the data set. The output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane.">
The Clip filter cuts away a portion of the input data set using an implicit plane. This filter operates on all types of data sets, and it returns unstructured grid data on output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1" optional="1"/>
         <Documentation>
           This property specifies the dataset on which the Clip filter will operate.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Scalar" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             This property specifies the parameters of the clip function (an implicit plane) used to clip the dataset.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             If clipping with scalars, this property specifies the name of the scalar array on which to perform the clip operation.
           </Documentation>
     </StringVectorProperty> 

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <DoubleRangeDomain name="range"/>

          <Documentation>
            If clipping with scalars, this property sets the scalar value about which to clip the dataset based on the scalar array chosen. (See SelectInputScalars.) If clipping with a clip function, this property specifies an offset from the clip function to use in the clipping operation. Neither functionality is currently available in ParaView's user interface.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
         name="InsideOut" 
         command="SetInsideOut" 
         number_of_elements="1"
         default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 0, the clip filter will return that portion of the dataset that lies within the clip function. If set to 1, the portions of the dataset that lie outside the clip function will be returned instead.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseValueAsOffset"
        command="SetUseValueAsOffset"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
           If UseValueAsOffset is true, Value is used as an offset parameter to the implicit function. Otherwise, Value is used only when clipping using a scalar array. 
        </Documentation>
     </IntVectorProperty>

     <Hints>
       <Visibility replace_input="2" />
       <Property name="UseValueAsOffset" show="0"/>
     </Hints>
   <!-- End Clip -->
   </SourceProxy>

   <SourceProxy name="Threshold" class="vtkThreshold">
    <Documentation
       long_help="This filter extracts cells that have point or cell scalars in the specified range."
       short_help="Extract cells that satisfy a threshold criterion.">
The Threshold filter extracts the portions of the input dataset whose scalars lie within the specified range. This filter operates on either point-centered or cell-centered data. This filter operates on any type of dataset and produces unstructured grid output.

To select between these two options, select either Point Data or Cell Data from the Attribute Mode menu. Once the Attribute Mode has been selected, choose the scalar array from which to threshold the data from the Scalars menu. The Lower Threshold and Upper Threshold sliders determine the range of the scalars to retain in the output. The All Scalars check box only takes effect when the Attribute Mode is set to Point Data. If the All Scalars option is checked, then a cell will only be passed to the output if the scalar values of all of its points lie within the range indicated by the Lower Threshold and Upper Threshold sliders. If unchecked, then a cell will be added to the output if the specified scalar value for any of its points is within the chosen range.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" number_of_components="1">
             <RequiredProperties>
                <Property name="SelectInputScalars" 
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
          <Documentation>
            This property specifies the input to the Threshold filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" 
                            attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
           <Documentation>
             The value of this property contains the name of the scalar array from which to perform thresholding.
           </Documentation>
     </StringVectorProperty> 

     <DoubleVectorProperty 
        name="ThresholdBetween" 
        command="ThresholdBetween"
        number_of_elements="2"
        default_values="0 0"
        label="Threshold Range">
          <ArrayRangeDomain name="range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <Documentation>
            The values of this property specify the upper and lower bounds of the thresholding operation.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="AllScalars" 
        command="SetAllScalars" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then a cell is only included in the output if the value of the selected array for all its points is within the threshold. This is only relevant when thresholding by a point-centered array.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End Threshold -->
   </SourceProxy>

   <SourceProxy name="Contour" class="vtkContourFilter">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The Contour filter operates on any type of data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1"/>
          <Documentation>
            This property specifies the input dataset to be used by the contour filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Contour By">
          <ArrayListDomain name="array_list" attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property specifies the name of the scalar array from which the contour filter will compute isolines and/or isosurfaces.
          </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        label="Isosurfaces"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            This property specifies the values at which to compute isosurfaces/isolines and also the number of such values.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ComputeNormals" 
        command="SetComputeNormals" 
        number_of_elements="1"
        default_values="1" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, a scalar array containing a normal value at each point in the isosurface or isoline will be created by the contour filter; otherwise an array of normals will not be computed. This operation is fairly expensive both in terms of computation time and memory required, so if the output dataset produced by the contour filter will be processed by filters that modify the dataset's topology or geometry, it may be wise to set the value of this property to 0.
         Select whether to compute normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeGradients" 
        command="SetComputeGradients" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, a scalar array containing a gradient value at each point in the isosurface or isoline will be created by this filter; otherwise an array of gradients will not be computed. This operation is fairly expensive both in terms of computation time and memory required, so if the output dataset produced by the contour filter will be processed by filters that modify the dataset's topology or geometry, it may be wise to set the value of this property to 0. Not that if ComputeNormals is set to 1, then gradients will have to be calculated, but they will only be stored in the output dataset if ComputeGradients is also set to 1.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeScalars" 
        command="SetComputeScalars" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, an array of scalars (containing the contour value) will be added to the output dataset. If set to 0, the output will not contain this array.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End Contour -->
   </SourceProxy>


   <SourceProxy name="Glyph" class="vtkPVGlyphFilter">
    <Documentation
       long_help="This filter generates an arrow, cone, cube, cylinder, line, sphere, or 2D glyph at each point of the input data set.  The glyphs can be oriented and scaled by point attributes of the input dataset."
       short_help="Generate a glyph symbol at each point of the input data set.">
The Glyph filter generates a glyph (i.e., an arrow, cone, cube, cylinder, line, sphere, or 2D glyph) at each point in the input dataset. The glyphs can be oriented and scaled by the input point-centered scalars and vectors. The Glyph filter operates on any type of data set. Its output is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <Documentation>
            This property specifies the input to the Glyph filter. This is the dataset to which the glyphs will be applied.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
          <ArrayListDomain name="array_list" attribute_type="Scalars" 
               input_domain_name="input_array1">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the scalar array on which to operate. The indicated array may be used for scaling the glyphs. (See the SetScaleMode property.)
          </Documentation>
     </StringVectorProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1" 
        label="Vectors">  <!-- default value=1 so normals go to the right place -->
          <ArrayListDomain name="array_list" attribute_type="Vectors"
               input_domain_name="input_array2">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the vector array on which to operate. The indicated array may be used for scaling and/or orienting the glyphs. (See the SetScaleMode and SetOrient properties.)
          </Documentation>
     </StringVectorProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Glyph Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="glyph_sources" />
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="sources" name="ArrowSource" />
              <Proxy group="sources" name="ConeSource" />
              <Proxy group="sources" name="CubeSource" />
              <Proxy group="sources" name="CylinderSource" />
              <Proxy group="sources" name="LineSource" />
              <Proxy group="sources" name="SphereSource" />
              <Proxy group="sources" name="GlyphSource2D" />
           </ProxyListDomain>
           <Documentation>
             This property determines which type of glyph will be placed at the points in the input dataset.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        label="Orient"
        name="SetOrient" 
        command="SetOrient" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the glyphs will be oriented based on the selected vector array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        label="Scale Mode"
        name="SetScaleMode" 
        command="SetScaleMode" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="scalar"/>
         <Entry value="1" text="vector"/>
         <Entry value="2" text="vector_components"/>
         <Entry value="3" text="off"/>
       </EnumerationDomain>
       <Documentation>
         The value of this property specifies how/if the glyphs should be scaled based on the point-centered scalars/vectors in the input dataset.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="SetScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <ArrayRangeDomain name="scalar_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <ArrayRangeDomain name="vector_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputVectors" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <Documentation>
         The value of this property will be used as a multiplier for scaling the glyphs before adding them to the output.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfPoints" 
        command="SetMaximumNumberOfPoints" 
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points">
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property specifies the maximum number of glyphs that should appear in the output dataset if the value of the UseMaskPoints property is 1. (See the UseMaskPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseMaskPoints" 
        command="SetUseMaskPoints" 
        number_of_elements="1"
        default_values="1"
        label="Mask Points"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, limit the maximum number of glyphs to the value indicated by MaximumNumberOfPoints. (See the MaximumNumberOfPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then the points to glyph are chosen randomly. Otherwise the point ids chosen are evenly spaced.
       </Documentation>
     </IntVectorProperty>
   <Hints>
     <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
     <Visibility replace_input="0" />
   </Hints>
   <!-- End Glyph -->
   </SourceProxy>

   <SourceProxy name="ArbitrarySourceGlyph" class="vtkPVGlyphFilter"
    label="Glyph (Custom Source)">
    <Documentation
       long_help="This filter generates a glyph at each point of the input data set.  The glyphs can be oriented and scaled by point attributes of the input dataset."
       short_help="Generate a glyph symbol at each point of the input data set.">
The Glyph filter generates a glyph at each point in the input dataset. The glyphs can be oriented and scaled by the input point-centered scalars and vectors. The Glyph filter operates on any type of data set. Its output is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <Documentation>
            This property specifies the input to the Glyph filter. This is the dataset to which the glyphs will be applied.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Glyph Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="glyph_sources" />
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             This property determines which type of glyph will be placed at the points in the input dataset.
           </Documentation>
      </InputProperty>


     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
          <ArrayListDomain name="array_list" attribute_type="Scalars" 
               input_domain_name="input_array1">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the scalar array on which to operate. The indicated array may be used for scaling the glyphs. (See the SetScaleMode property.)
          </Documentation>
     </StringVectorProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1" 
        label="Vectors">  <!-- default value=1 so normals go to the right place -->
          <ArrayListDomain name="array_list" attribute_type="Vectors"
               input_domain_name="input_array2">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the vector array on which to operate. The indicated array may be used for scaling and/or orienting the glyphs. (See the SetScaleMode and SetOrient properties.)
          </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        label="Orient"
        name="SetOrient" 
        command="SetOrient" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the glyphs will be oriented based on the selected vector array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        label="Scale Mode"
        name="SetScaleMode" 
        command="SetScaleMode" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="scalar"/>
         <Entry value="1" text="vector"/>
         <Entry value="2" text="vector_components"/>
         <Entry value="3" text="off"/>
       </EnumerationDomain>
       <Documentation>
         The value of this property specifies how/if the glyphs should be scaled based on the point-centered scalars/vectors in the input dataset.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="SetScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <ArrayRangeDomain name="scalar_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <ArrayRangeDomain name="vector_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputVectors" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <Documentation>
         The value of this property will be used as a multiplier for scaling the glyphs before adding them to the output.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfPoints" 
        command="SetMaximumNumberOfPoints" 
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points">
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property specifies the maximum number of glyphs that should appear in the output dataset if the value of the UseMaskPoints property is 1. (See the UseMaskPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseMaskPoints" 
        command="SetUseMaskPoints" 
        number_of_elements="1"
        default_values="1"
        label="Mask Points"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, limit the maximum number of glyphs to the value indicated by MaximumNumberOfPoints. (See the MaximumNumberOfPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then the points to glyph are chosen randomly. Otherwise the point ids chosen are evenly spaced.
       </Documentation>
     </IntVectorProperty>
   <Hints>
     <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
          replace_input="1" implies always replace input.
          replace_input="2" implies replace input only when input is shown as a
                            solid i.e surface or surface with edges.
       -->
     <Visibility replace_input="0" />
   </Hints>
   <!-- End Glyph -->
   </SourceProxy>

   <SourceProxy name="ExtractGrid" class="vtkPVExtractVOI"
    label="Extract Subset">
    <Documentation
       long_help="Extract a subgrid from a structured grid with the option of setting subsample strides."
       short_help="Extract a subgrid or subsample.">
The Extract Grid filter returns a subgrid of a structured input data set (uniform rectilinear, curvilinear, or nonuniform rectilinear). The output data set type of this filter is the same as the input type.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
            <DataType value="vtkRectilinearGrid"/>
            <DataType value="vtkStructuredPoints"/>
            <DataType value="vtkStructuredGrid"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Extract Grid filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="VOI" 
        command="SetVOI"
        number_of_elements="6"
        default_values="0 0 0 0 0 0">
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
       <Documentation>
         This property specifies the minimum and maximum point indices along each of the I, J, and K axes; these values indicate the volume of interest (VOI). The output will have the (I,J,K) extent specified here.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateI" 
        command="SetSampleRateI"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         This property indicates the sampling rate in the I dimension. A value grater than 1 results in subsampling; every nth index will be included in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateJ" 
        command="SetSampleRateJ"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         This property indicates the sampling rate in the J dimension. A value grater than 1 results in subsampling; every nth index will be included in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateK" 
        animateable="1"
        command="SetSampleRateK"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         This property indicates the sampling rate in the K dimension. A value grater than 1 results in subsampling; every nth index will be included in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IncludeBoundary" 
        command="SetIncludeBoundary" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then if the sample rate in any dimension is greater than 1, the boundary indices of the input dataset will be passed to the output even if the boundary extent is not an even multiple of the sample rate in a given dimension.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End ExtractGrid -->
   </SourceProxy>

   <SourceProxy name="ProbePoint" class="vtkPProbeFilter"
    label="Probe Location">
    <Documentation
       long_help="Sample data attributes at the points in a point cloud."
       short_help="Sample data values at the points in a point cloud.">
The Probe filter samples the data set attributes of the current data set at the points in a point cloud. The Probe filter uses interpolation to determine the values at the selected point, whether or not it lies at an input point. The Probe filter operates on any type of data and produces polygonal output (a point cloud).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            This property specifies the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection"
        label="Probe Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
             <Proxy group="extended_sources" name="FixedRadiusPointSource" />
           </ProxyListDomain>
           <Documentation>
             This property specifies the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End ProbePoint -->
   </SourceProxy>

   <SourceProxy name="ProbeLine" class="vtkPProbeFilter"
    label="Plot Over Line">
    <Documentation
       long_help="Sample data attributes at the points along a line.  Probed lines will be displayed in a graph of the attributes."
       short_help="Sample data values at the points along a line.">
The Plot Over Line filter samples the data set attributes of the current data set at the points along a line. The values of the point-centered variables along that line will be displayed in an XY Plot. This filter uses interpolation to determine the values at the selected point, whether or not it lies at an input point. The Probe filter operates on any type of data and produces polygonal output (a line).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            This property specifies the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection"
        label="Probe Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
             <Proxy group="extended_sources" name="HighResLineSource" />
           </ProxyListDomain>
           <Documentation>
             This property specifies the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End ProbeLine -->
   </SourceProxy>

   <SourceProxy name="Probe" class="vtkPProbeFilter"
    label="Resample with dataset">
    <Documentation
       long_help="Sample data attributes at the points of a dataset."
       short_help="Sample data values at the points of a dataset.">
Probe is a filter that computes point attributes at specified point positions. The filter has two inputs: the Input and Source. The Input geometric structure is passed through the filter. The point attributes are computed at the Input point positions by interpolating into the source data. For example, we can compute data values on a plane (plane specified as Input) from a volume (Source). The cell data of the source data is copied to the output based on in which source cell each input point is. If an array of the same name existsboth in source's point and cell data, only the one from the point data is probed.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            This property specifies the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
           <Documentation>
             This property specifies the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End Probe -->
   </SourceProxy>

   <SourceProxy name="StreamTracer" class="vtkDistributedStreamTracer"
    label="Stream Tracer">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. Production of streamlines terminates if a streamline crosses the exterior boundary of the input dataset. Other reasons for termination are listed for the MaximumNumberOfSteps, TerminalSpeed, and MaximumPropagation properties. This filter operates on any type of dataset, provided it has point-centered vectors. The output is polygonal data containing polylines. 
    </Documentation>
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="1">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            This property specifies the input to the Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Seed Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="extended_sources" name="PointSource" />
              <Proxy group="extended_sources" name="LineSource" />
           </ProxyListDomain>
           <Documentation>
             The value of this property determines how the seeds for the streamlines will be generated.
           </Documentation>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty 
        name="MaximumPropagationUnit" 
        label="Max. Propagation Unit"
        command="SetMaximumPropagationUnit" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates the unit for specifying the maximum streamline length. The Time (0) unit is the time a particle would travel with steady flow. The Length (1) unit is specified in the dataset's spatial coordinates.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        label="Max. Propagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         The value of this property specifies the maximum streamline length. If the streamline length goes beyond this value, integration of that strealine terminates.
       </Documentation>       
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        label="Initial Step Unit"
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates the unit for specifying the initial integration step. The Time (0) and Length (1) units have the same meaning as that specified in the MaximumPropagationUnit property. The Cell Length (2) unit specifies the step length as a number of cells.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        label="Initial Step Length"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the initial integration step. For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="IntegrationDirection" 
        command="SetIntegrationDirection" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         This property determines in which direction(s) the stream trace will be generated.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         This property determines which calculation to use for integration.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum error allowed in the integration. The meaning of this value depends on the integrator chosen. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of this property.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        label="Minimum Step Unit"
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         If the Runge-Kutta 4-5 integrator is selected (IntegratorType property), this property determines the unit to use for specifying the minimum integration step. Time (0), Length (1), and Cell Length (2) have the same meanings as those indicated for the InitialIntegrationStepUnit property.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        label="Minimum Step Length"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If using the Runge-Kutta 4-5 ingrator (IntegratorType property), this property specifies the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        label="Maximum Step Unit"
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         If the Runge-Kutta 4-5 integrator is selected (IntegratorType property), this property determines the unit to use for specifying the maximum integration step. Time (0), Length (1), and Cell Length (2) have the same meanings as those indicated for the InitialIntegrationStepUnit property.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        label="Maximum Step Length"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If using the Runge-Kutta 4-5 ingrator (IntegratorType property), this property specifies the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfSteps" 
        label="Max. Steps"
        command="SetMaximumNumberOfSteps" 
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         If the integration takes more steps to complete than indicated by this property, the integration terminates.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        label="Term. Speed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If at any point the speed is below the value of this property, the integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End StreamTracer -->
   </SourceProxy>

   <SourceProxy name="ArbitrarySourceStreamTracer" class="vtkDistributedStreamTracer"
    label="Stream Tracer (Custom Source)">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. Production of streamlines terminates if a streamline crosses the exterior boundary of the input dataset. Other reasons for termination are listed for the MaximumNumberOfSteps, TerminalSpeed, and MaximumPropagation properties. This filter operates on any type of dataset, provided it has point-centered vectors. The output is polygonal data containing polylines. 
    </Documentation>
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="1">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            This property specifies the input to the Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Seed Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <Documentation>
             The value of this property determines how the seeds for the 
             streamlines will be generated.
           </Documentation>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty 
        name="MaximumPropagationUnit" 
        label="Max. Propagation Unit"
        command="SetMaximumPropagationUnit" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates the unit for specifying the maximum streamline length. The Time (0) unit is the time a particle would travel with steady flow. The Length (1) unit is specified in the dataset's spatial coordinates.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        label="Max. Propagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         The value of this property specifies the maximum streamline length. If the streamline length goes beyond this value, integration of that strealine terminates.
       </Documentation>       
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        label="Initial Step Unit"
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates the unit for specifying the initial integration step. The Time (0) and Length (1) units have the same meaning as that specified in the MaximumPropagationUnit property. The Cell Length (2) unit specifies the step length as a number of cells.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        label="Initial Step Length"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the initial integration step. For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="IntegrationDirection" 
        command="SetIntegrationDirection" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         This property determines in which direction(s) the stream trace will be generated.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         This property determines which calculation to use for integration.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum error allowed in the integration. The meaning of this value depends on the integrator chosen. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of this property.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        label="Minimum Step Unit"
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         If the Runge-Kutta 4-5 integrator is selected (IntegratorType property), this property determines the unit to use for specifying the minimum integration step. Time (0), Length (1), and Cell Length (2) have the same meanings as those indicated for the InitialIntegrationStepUnit property.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        label="Minimum Step Length"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If using the Runge-Kutta 4-5 ingrator (IntegratorType property), this property specifies the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        label="Maximum Step Unit"
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         If the Runge-Kutta 4-5 integrator is selected (IntegratorType property), this property determines the unit to use for specifying the maximum integration step. Time (0), Length (1), and Cell Length (2) have the same meanings as those indicated for the InitialIntegrationStepUnit property.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        label="Maximum Step Length"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If using the Runge-Kutta 4-5 ingrator (IntegratorType property), this property specifies the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfSteps" 
        label="Max. Steps"
        command="SetMaximumNumberOfSteps" 
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         If the integration takes more steps to complete than indicated by this property, the integration terminates.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        label="Term. Speed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If at any point the speed is below the value of this property, the integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End StreamTracer -->
   </SourceProxy>

    <SourceProxy name="TemporalCache" class="vtkTemporalDataSetCache"
                 label="Temporal Cache">
      <Documentation short_help="Caches data per time step."
                     long_help="Saves a copy of the data set for a fixed number of time steps.">
        The Temporal Cache can be used to save multiple copies of a data set at different time steps to prevent thrashing in the pipeline caused by downstream filters that adjust the requested time step.  For example, assume that there is a downstream Temporal Interpolator filter.  This filter will (usually) request two time steps from the upstream filters, which in turn (usually) causes the upstream filters to run twice, once for each time step.  The next time the interpolator requests the same two time steps, they might force the upstream filters to re-evaluate the same two time steps.  The Temporal Cache can keep copies of both of these time steps and provide the requested data without having to run upstream filters.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input of the Temporal Cache filter.
        </Documentation>
      </InputProperty>

      <IntVectorProperty 
         name="CacheSize" 
         command="SetCacheSize" 
         number_of_elements="1"
         default_values="2" >
        <IntRangeDomain name="range" min="2" max="10"/>
        <Documentation>
          The cache size determines the number of time steps that can be cached at one time.  The maximum number is 10.  The minimum is 2 (since it makes little sense to cache less than that).
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty 
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>

      <!-- End TemporalCache -->
    </SourceProxy>

    <SourceProxy name="TemporalInterpolator" class="vtkTemporalInterpolator"
                 label="Temporal Interpolator">
      <Documentation short_help="Interpolate between time steps."
                     long_help="Interpolate between time steps.">
        The Temporal Interpolator converts data that is defined at discrete time steps to one that is defined over a continuum of time by linearly interpolating the data's field data between two adjacent time steps.  The interpolated values are a simple approximation and should not be interpreted as anything more.  The Temporal Interpolator assumes that the topology between adjacent time steps does not change.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input of the Temporal Interpolator.
        </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="DiscreteTimeStepInterval"
         command="SetDiscreteTimeStepInterval"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          If Discrete Time Step Interval is set to 0, then the Temporal Interpolator will provide a continuous region of time on its output.  If set to anything else, then the output will define a finite set of time points on its output, each spaced by the Discrete Time Step Interval.  The output will have (time range)/(discrete time step interval) time steps.  (Note that the time range is defined by the time range of the data of the input filter, which may be different from other pipeline objects or the range defined in the animation inspector.)  This is a useful option to use if you have a dataset with one missing time step and wish to 'file-in' the missing data with an interpolated value from the steps on either side.
        </Documentation>
      </DoubleVectorProperty>      

      <DoubleVectorProperty 
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>

      <!-- End TemporalInterpolator -->
    </SourceProxy>

    <SourceProxy name="TemporalSnapToTimeStep" class="vtkTemporalSnapToTimeStep">
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject"/>
        </DataTypeDomain>
      </InputProperty>

      <IntVectorProperty 
         name="SnapMode" 
         command="SetSnapMode" 
         number_of_elements="1"
         default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="Nearest"/>
          <Entry value="1" text="NextBelowOrEqual"/>
          <Entry value="2" text="NextAboveOrEqual"/>
        </EnumerationDomain>
        <Documentation>
          Determine which time step to snap to.
        </Documentation>
      </IntVectorProperty>
      
      <DoubleVectorProperty 
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>
      
      <!-- End TemporalSnapToTimeStep -->
    </SourceProxy>

    <SourceProxy name="TemporalShiftScale" class="vtkTemporalShiftScale"
                 label="Temporal Shift Scale">
      <Documentation short_help="Shift and scale time values."
                     long_help="Shift and scale time values.">
        The Temporal Shift Scale filter linearly transforms the time values of a pipeline object by applying a shift and then scale.  Given a data at time t on the input, it will be transformed to time t*Shift + Scale on the output.  Inversely, if this filter has a request for time t, it will request time (t-Shift)/Scale on its input.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject"/>
        </DataTypeDomain>
        <Documentation>
          The input to the Temporal Shift Scale filter.
        </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="Shift"
         command="SetShift"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          The amount of time the input is shifted.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Scale"
         command="SetScale"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          The factor by which the input time is scaled.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty 
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>

      <!-- End TemporalShiftScale -->
    </SourceProxy>

    <SourceProxy name="ParticleTracer" class="vtkTemporalStreamTracer">
    <Documentation
       long_help="Trace Particles through time in a vector field."
       short_help="Trace Particles through time in a vector field.">
The Particle Trace filter generates pathlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter is available on the Toolbar.
    </Documentation>
     
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type" composite_data_supported="1">
         <DataType value="vtkTemporalDataSet"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array" attribute_type="point"
                         number_of_components="3"/>
     </InputProperty>

     <InputProperty
        name="Source2"
        command="SetSource2Connection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
     </InputProperty>
      
      <InputProperty
         name="Source"
         command="SetSourceConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>
      
     <IntVectorProperty
                       name="EnableSource1"
                       command="SetEnableSource1"
                       number_of_elements="1"
                       default_values="1" >
       <BooleanDomain name="bool"/>
     </IntVectorProperty>
     
     <IntVectorProperty
                       name="EnableSource2"
                       command="SetEnableSource2"
                       number_of_elements="1"
                       default_values="0" >
       <BooleanDomain name="bool"/>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TimeStepResolution"
        command="SetTimeStepResolution"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty
       name="TimeStep"
       command="SetTimeStep"
       number_of_elements="1"
       animateable="1"
       default_values="0"
       information_property="TimestepValues">

       <IntRangeDomain name="range">
         <RequiredProperties>
           <Property name="TimeStepRangeInfo" function="Range"/>
         </RequiredProperties>
       </IntRangeDomain>
     </IntVectorProperty>

     <DoubleVectorProperty 
        name="TimestepValues"
        information_only="1">
       <TimeStepsInformationHelper/>
     </DoubleVectorProperty>
     
     <IntVectorProperty 
        name="ForceReinjectionEveryNSteps" 
        command="SetForceReinjectionEveryNSteps" 
        number_of_elements="1"
        default_values="0" >
     </IntVectorProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"> 
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
     </StringVectorProperty>

      <DoubleVectorProperty
        name="InitialIntegrationStep"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.25" >
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>
<!--      
      <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
-->

      <IntVectorProperty 
         name="IgnorePipelineTime" 
         command="SetIgnorePipelineTime" 
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Ignore the TIME_ requests made by the pipeline and only use the TimeStep set manually
        </Documentation>
      </IntVectorProperty>
<!--
      <StringVectorProperty 
         name="ParticleFileName" 
         command="SetParticleFileName" 
         number_of_elements="1"
         default_values="D:/Particles.h5">
        <Documentation>
          Provide a name for the particle file generated if writing is enabled
        </Documentation>
      </StringVectorProperty>

      <IntVectorProperty 
         name="EnableParticleWriting" 
         command="SetEnableParticleWriting" 
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Turn On/Off particle writing
        </Documentation>
      </IntVectorProperty>
-->      
      <!-- End ParticleTracer -->
   </SourceProxy>
    
   <SourceProxy name="StructuredGridOutlineFilter" 
                class="vtkStructuredGridOutlineFilter"
                label="Outline (curvilinear)">
      <Documentation
         long_help="This filter generates an outline representation of the input."
         short_help="Generates an outline.">
The Outline filter generates an outline of the outside edges of the input dataset, rather than the dataset's bounding box. This filter operates on structured grid datasets and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkStructuredGrid"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the outline (curvilinear) filter.
           </Documentation>
      </InputProperty>
   <!-- End StructuredGridOutlineFilter -->
   </SourceProxy>

  <SourceProxy name="GenericClip" class="vtkGenericClip" label="Clip (Generic Datasets)">
    <Documentation
       long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane, sphere or with scalars.">
The Generic Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            optional="1"/>
          <Documentation>
            Set the input to the Generic Clip filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Set the parameters of the clip function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InsideOut" 
        command="SetInsideOut" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Choose which portion of the dataset should be clipped away.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <DoubleRangeDomain name="range"/>
          <Documentation>
            If clipping with a scalar array, choose the clipping value.
          </Documentation>
     </DoubleVectorProperty>
   <!-- End GenericClip -->
   </SourceProxy>

   <SourceProxy name="GenericContour" class="vtkGenericContourFilter" label="Contour (Generic Datasets)">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Generic Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Generic Contour filter operates on a generic data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <Documentation>
            Set the input to the Generic Contour filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            Specify the current contour values.
          </Documentation>          
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ComputeNormals" 
        command="SetComputeNormals" 
        number_of_elements="1"
        default_values="1" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeGradients" 
        command="SetComputeGradients" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute gradients.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeScalars" 
        command="SetComputeScalars" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute scalars.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericContour -->
   </SourceProxy>

 <SourceProxy name="GenericCut" class="vtkGenericCutter" label="Slice (Generic Datasets)">
    <Documentation
       long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
       short_help="Cut datasets with planes or spheres.">
The Generic Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Generic Cut filter takes a generic dataset as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Generic Cut filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Cut Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Set the parameters to the implicit function used for cutting.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
          <Documentation>
            Specify a list of current offset values. This can be used to create multiple cuts with different centers. Each entry represents a new cut with center shifted by the offset value.
          </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericCut -->
   </SourceProxy>

  <SourceProxy name="GenericGeometryFilter" class="vtkGenericGeometryFilter"
               label="Extract Surface (Generic Datasets)">
     <Documentation
         long_help="Extract geometry from a higher-order dataset"
         short_help="Extract geometry from a higher-order dataset">
Extract geometry from a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Geometry Filter.
           </Documentation>
      </InputProperty>

   <!-- End GenericGeometryFilter -->
   </SourceProxy>

 <SourceProxy name="GenericOutlineFilter" class="vtkGenericOutlineFilter"
     label="Outline (Generic DataSets)">
     <Documentation
       long_help="This filter generates a bounding box representation of the input."
       short_help="Generates a bounding box.">
The Generic Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on generic data sets and produces polygonal output.
     </Documentation>
      
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Outline filter.
           </Documentation>
      </InputProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  GenericOutlineFilter -->
   </SourceProxy>

 <SourceProxy name="GenericStreamTracer" class="vtkGenericStreamTracer"
              label="Stream Tracer (Generic Datasets)">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Generic Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines.
    </Documentation>
       
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            Set the input to the Generic Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Specify the seed points for generating the streamlines.
           </Documentation>
      </InputProperty>

     <!-- This is a hack used to bypass the fact that ParaView
          does not have special proxies for things like point sources.
          It should be removed in the future -->
     <!-- TODO: Should this be removed now? -->
     <DoubleVectorProperty
        name="Radius"
        number_of_elements="1"
        default_values="0.1"
        information_only="1">
        <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          Set the radius of the point cloud for setting seed points.
        </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty 
        name="MaximumPropagationUnit" 
        command="SetMaximumPropagationUnit" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit for specifying the maximum streamline length.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         Specify the maximum streamline length.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit for specifying the initial integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the initial integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="IntegrationDirection" 
        command="SetIntegrationDirection" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         Choose the integration direction.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain>
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         Choose the type of integrator to use.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the maximum error allowed in the integration. The meaning of this value depends on the integrator chosen.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit to use for specifying the minimum integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit to use for specifying the maximum integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the maximum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfSteps" 
        command="SetMaximumNumberOfSteps" 
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         Specify the maximum number of steps used in the integration.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If at any point the speed is below this value, the integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericStreamTracer -->
   </SourceProxy>

  <SourceProxy name="GenericTessellator" class="vtkGenericDataSetTessellator"
               label="Tessellator (Generic Datasets)">
     <Documentation
         long_help="Tessellate a higher-order dataset"
         short_help="Tessellate a higher-order dataset">
Tessellate a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Tessellator filter.
           </Documentation>
      </InputProperty>

   <!-- End GenericTessellator -->
   </SourceProxy>

   <SourceProxy name="GroupDataSets" class="vtkMultiGroupDataGroupFilter"
    label="Group Datasets">
    <Documentation
        long_help="Group data sets."
        short_help="Group multiple inputs into one collection.">
Groups multiple datasets to create a multigroup dataset
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="1">
             <DataType value="vtkDataObject"/>
           </DataTypeDomain>
           <Documentation>
             This property indicates the the inputs to the Group Datasets filter.
           </Documentation>
     </InputProperty>
     <Hints>
       <Visibility replace_input="1" />
     </Hints>
   <!-- End GroupDataSets -->
   </SourceProxy>

   <SourceProxy name="GroupIdScalars" class="vtkMultiGroupDataGroupIdScalars"
      label="Level Scalars">
     <Documentation
        long_help="The Level Scalars filter uses colors to show levels of a hierarchical dataset."
        short_help="Generate point scalars from level.">
The Level Scalars filter uses colors to show levels of a hierarchical dataset.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Level Scalars filter.
           </Documentation>
     </InputProperty>
   <!-- End GroupIdScalars -->
   </SourceProxy>

    <SourceProxy name="GeometryFilter" class="vtkPVGeometryFilter">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the Geoemtry Filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="UseStrips"
        command="SetUseStrips"
        number_of_elements="1"
        is_internal="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/> 
        <Documentation>
          Toggle whether to generate faces containing triangle strips. This should render faster and use less memory, but no cell data is copied.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="ForceStrips"
        command="SetForceUseStrips"
        number_of_elements="1"
        is_internal="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/> 
        <Documentation>
          This makes UseStrips call Modified() after changing its setting to ensure that the filter's output is immediatley changed.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="UseOutline"
        command="SetUseOutline"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Toggle whether to generate an outline or a surface.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="PassThroughIds"
        command="SetPassThroughCellIds"
        number_of_elements="1"
        default_values="1"
        animateable="0">
        <BooleanDomain name="bool"/> 
        <Documentation>
          If on, the output polygonal dataset will have a celldata array that holds the cell index of the original 3D cell that produced each output cell. This is useful for cell picking.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="PassThroughPointIds"
        command="SetPassThroughPointIds"
        number_of_elements="1"
        default_values="1"
        animateable="0">
        <BooleanDomain name="bool"/> 
        <Documentation>
          If on, the output polygonal dataset will have a pointdata array that holds the point index of the original 3D vertex that produced each output vertex. This is useful for picking.
        </Documentation>
      </IntVectorProperty>
    <!-- End GeometryFilter -->
    </SourceProxy>

    <SourceProxy name="OrderedCompositeDistributor"
                 class="vtkOrderedCompositeDistributor">
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <Documentation>
          Set the input to the Ordered Composite Distributor filter.
        </Documentation>
      </InputProperty>
      <IntVectorProperty name="PassThrough"
                         command="SetPassThrough"
                         number_of_elements="1"
                         default_values="0"
                         animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Toggle whether to pass the data through without compositing.
        </Documentation>
      </IntVectorProperty>
      <ProxyProperty name="PKdTree" command="SetPKdTree">
        <ProxyGroupDomain name="groups">
          <Group name="locators"/>
        </ProxyGroupDomain>
        <Documentation>
          Set the vtkPKdTree to distribute with.
        </Documentation>
      </ProxyProperty>
      <StringVectorProperty name="OutputType"
                            command="SetOutputType"
                            number_of_elements="1">
        <Documentation>
          When not empty, the output will be converted to the given type.
        </Documentation>
      </StringVectorProperty>
    <!-- End OrderedCompositeDistributor -->
    </SourceProxy>

    <UpdateSuppressorProxy name="UpdateSuppressor" class="vtkPVUpdateSuppressor"
      executive="vtkUpdateSuppressorPipeline">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the Update Suppressor filter.
          </Documentation>
      </InputProperty>
      <Property
        name="ForceUpdate"
        command="ForceUpdate"
        is_internal="1">
      </Property>
      <Property
        name="RemoveAllCaches"
        command="RemoveAllCaches"
        immediate_update="1">
      </Property>
      <IntVectorProperty
        name="CacheUpdate"
        command="CacheUpdate"
        number_of_elements="2"
        default_values="0 -1"
        is_internal="1">
        <IntRangeDomain name="range" min="0 -1" />
      </IntVectorProperty>
      <IntVectorProperty
        name="SaveCacheOnCacheUpdate"
        command="SetSaveCacheOnCacheUpdate"
        number_of_elements="1"
        is_internal="1"
        default_values="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty
        name="Enabled"
        command="SetEnabled"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle whether the update suppressor is enabled.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty
        name="UpdateTime"
        command="SetUpdateTime"
        number_of_elements="1"
        default_values="none"
        immediate_update="1"
        is_internal="1">
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>
    <!-- End UpdateSuppressor -->
    </UpdateSuppressorProxy>

    <UpdateSuppressorProxy name="UpdateSuppressor2" class="vtkPVUpdateSuppressor"
      executive="vtkUpdateSuppressorPipeline">

      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Update Suppressor filter.
          </Documentation>
      </InputProperty>

      <Property name="ForceUpdate" command="ForceUpdate" />
      <Property name="RemoveAllCaches" command="RemoveAllCaches" />

      <DoubleVectorProperty
        name="CacheUpdate"
        command="CacheUpdate"
        number_of_elements="1"
        default_values="none"
        is_internal="1" >
        <DoubleRangeDomain name="range" />
      </DoubleVectorProperty>
      
      <IntVectorProperty
        name="Enabled"
        command="SetEnabled"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle whether the update suppressor is enabled.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
        name="UpdateTime"
        command="SetUpdateTime"
        number_of_elements="1"
        default_values="none"
        immediate_update="1"
        is_internal="1">
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>

      <!-- End UpdateSuppressor2 -->
    </UpdateSuppressorProxy>
    
    <SourceProxy name="MPIMoveData" class="vtkMPIMoveData">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the MPI Move Data filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="MoveMode"
        command="SetMoveMode"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PassThrough" />
          <Entry value="1" text="Collect" />
          <Entry value="2" text="Clone" />
        </EnumerationDomain>
        <Documentation>
          Specify how the data is to be redistributed.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="OutputDataType"
        command="SetOutputDataType"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PolyData" />
          <Entry value="4" text="Unstructured Grid" />
          <Entry value="6" text="ImageData" />
        </EnumerationDomain>
        <Documentation>
          Specify the type of the dataset.
        </Documentation>
      </IntVectorProperty>
    <!-- End MPIMoveData -->
    </SourceProxy>

    <SourceProxy name="ClientServerMoveData" class="vtkClientServerMoveData">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Client Server Move Data filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="OutputDataType"
        command="SetOutputDataType"
        number_of_elements="1"
        default_values="0"
        animateable="0">
      </IntVectorProperty>
    <!-- End ClientServerMoveData -->
    </SourceProxy>
        
    <SourceProxy name="ReductionFilter" class="vtkReductionFilter">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Reduction filter.
          </Documentation>
      </InputProperty>
      <ProxyProperty name="PreGatherHelper"
         command="SetPreGatherHelper">
         <Documentation>
           Set the algorithm that runs on each node in parallel.
         </Documentation>
      </ProxyProperty>
      <ProxyProperty name="PostGatherHelper"
         command="SetPostGatherHelper">
         <Documentation>
           Set the algorithm that takes multiple inputs and produces a single reduced output.
         </Documentation>
      </ProxyProperty>
      <IntVectorProperty 
         name="PassThrough" 
         command="SetPassThrough" 
         number_of_elements="1"
         default_values="-1"> 
        <IntRangeDomain name="range" min="-1"/>
        <Documentation>
          If set to a non-negative value, then produce results using only the node Id specified.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
         name="GenerateProcessIds"
         command="SetGenerateProcessIds"
         number_of_elements="1"
         default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          If true, the filter will generate vtkOriginalProcessIds arrays
          indicating the process id on which the cell/point was generated. 
        </Documentation>
      </IntVectorProperty>

    <!-- End ReductionFilter -->
    </SourceProxy>

   <SourceProxy name="ExtractLevel" class="vtkMultiGroupDataExtractGroup"
     label="Extract Group">
     <Documentation
        long_help="This filter extracts a range of groups from a multigroup dataset."
        short_help="Extract level.">
This filter extracts a range of groups from a multigroup dataset    
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
           <NumberOfGroupsDomain name="multi_group" multiplicity="multiple"/>
           <Documentation>
             This property specifies the input to the Extract Group filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="GroupRange" 
        command="SetGroupRange" 
        number_of_elements="2"
        default_values="0 0" > 
       <NumberOfGroupsDomain name="range">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
       </NumberOfGroupsDomain>
       <Documentation>
         This property lists the ids of the minimum and maximum group to extract from the input multigroup dataset.
       </Documentation>
     </IntVectorProperty>
   <!-- End ExtractLevel -->
   </SourceProxy>

   <SourceProxy name="ExtractDataSets" 
                class="vtkMultiGroupDataExtractDataSets"
                label="Extract Datasets">
     <Documentation
        long_help="This filter extracts a list of datasets from multigroup datasets."
        short_help="Extract datasets.">
This filter extracts a list of datasets from multigroup datasets.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Datasets filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="SelectedDataSets" 
        command="AddDataSet"
        clean_command="ClearDataSetList"
        repeat_command="1"
        number_of_elements_per_command="2">
        <Documentation>
          This property provides a list of datasets to extract.
        </Documentation>
     </IntVectorProperty>
   <!-- End ExtractDataSets -->
   </SourceProxy>

   <SourceProxy name="ExtractHistogram" class="vtkPExtractHistogram"
                label="Histogram">
     <Documentation
        long_help="Extract a histogram from field data."
        short_help="Extract a histogram from field data.">
     </Documentation>
    
     <InputProperty name="Input" command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array">
             <RequiredProperties>
                <Property name="SelectInputArray" 
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
          <Documentation>
            This property specifies the input to the Histogram filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
         name="SelectInputArray" 
         command="SetInputArrayToProcess" 
         number_of_elements="5" 
         element_types="0 0 0 0 2" 
         animateable="0"> 
          <ArrayListDomain name="array_list" 
                           attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <FieldDataDomain name="field_list">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </FieldDataDomain>
          <Documentation>
            This property indicates the name of the array from which to compute the histogram.
          </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="BinCount" 
        command="SetBinCount" 
        number_of_elements="1" 
        default_values="10">
        <IntRangeDomain name="range" min="1" max="256"/>
        <Documentation>
          The value of this property specifies the number of bins for the histogram.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Component" 
        command="SetComponent" 
        number_of_elements="1" 
        default_values="0" 
        animateable="0"> 
        <IntRangeDomain name="range" min="0" max="15"/>
        <Documentation>
          The value of this property specifies the array component from which the histogram should be computed.
        </Documentation>
     </IntVectorProperty>

     <Hints>
       <!-- View can be used to specify the preferred view for the proxy -->
       <View type="BarChartView" />
     </Hints>
   <!-- End ExtractHistogram -->
   </SourceProxy>

   
   <SourceProxy name="RectilinearGridGeometryFilter" class="vtkRectilinearGridGeometryFilter">
      <Documentation
         long_help="Extracts geometry for a rectilinear grid.  Output is a polydata dataset."
         short_help="Extracts geometry for a rectilinear grid.">
         RectilinearGridGeometryFilter is a filter that extracts geometry from a rectilinear grid. By specifying appropriate i-j-k indices, it is possible to extract a point, a curve, a surface, or a "volume".  The volume is actually a (n x m x o) region of points.  The extent specification is zero-offset.  That is, the first k-plane in a 50x50x50 rectilinear grid is given by (0,49, 0,49, 0,0).
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Rectilinear Grid Geometry filter.
           </Documentation>
      </InputProperty>
         
   <!-- End RectilinearGridGeometryFilter -->
   </SourceProxy>

   <SourceProxy name="TextureMapToPlane" class="vtkTextureMapToPlane"
     label="Texture Map to Plane">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Plane filter.
          </Documentation>
     </InputProperty>
   <!-- End TextureMapToPlane -->
   </SourceProxy>

   <SourceProxy name="TextureMapToSphere" class="vtkTextureMapToSphere"
     label="Texture Map to Sphere">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Sphere filter.
          </Documentation>
     </InputProperty>
   <!-- End TextureMapToSphere -->
   </SourceProxy>

   <SourceProxy name="TextureMapToCylinder" class="vtkTextureMapToCylinder"
     label="Texture Map to Cylinder">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Cylinder filter.
          </Documentation>
     </InputProperty>
   <!-- End TextureMapToCylinder -->
   </SourceProxy>

   <SourceProxy name="PolyLineToRectilinearGrid"
                class="vtkPolyLineToRectilinearGridFilter"
                label="Polyline to Rectilinear Grid">
      <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Polyline to Rectilinear Grid filter.
          </Documentation>
     </InputProperty>     
     <!-- End PolyLineToRectilinearGrid -->
   </SourceProxy>

   <SourceProxy name="MinMax" class="vtkMinMax">
      <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Min Max filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="Operation" 
        command="SetOperation" 
        number_of_elements="1"
        default_values="MIN"> 
        <StringListDomain name="operation">
          <String value="MIN"/>
          <String value="MAX"/>
          <String value="SUM"/>
        </StringListDomain>
        <Documentation>
          Select whether to perform a min, max, or sum operation on the data.
        </Documentation>
     </StringVectorProperty>
     <!-- End MinMax -->
   </SourceProxy>

   <SourceProxy name="ExtractSelection" label="Extract Selection" 
                class="vtkPVExtractSelection">
     <Documentation>
       This filter extracts a given set of cells or points given a selection. 
       The selection can be obtained from a rubber-band selection 
       (either point, cell, visible or in a frustum) and passed to the filter 
       or specified by providing an ID list.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>
     <InputProperty
         name="Selection"
         command="SetSelectionConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkSelection"/>
       </DataTypeDomain>
       <Documentation>
         The input that provides the selection object.
       </Documentation>
     </InputProperty>
     <!-- End ExtractSelection -->
   </SourceProxy>
<!--
   <ExtractSelectionProxy name="ExtractPointSelection" 
      label="Extract Selection (point)"
      class="vtkExtractSelection"
      selection_field_type="POINT" >
     <Documentation
      short_help="Extract selection by point."
      long_help="Extract selection by point." >
       This filter extracts a set of points given a selection. 
       The selection can be created by specifying a point id list (either 
       global ids or point indices).
     </Documentation>

     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         This property specifies the input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <IdTypeVectorProperty 
        name="Indices"
        command="AddIndex"
        clean_command="RemoveAllIndices"
        repeat_command="1"
        number_of_elements_per_command="2"
        number_of_elements="2"
        update_self="1"
        label="Indices" 
        default_values="0 0">
        <Documentation>
          This property contains the list of IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IdTypeVectorProperty 
        name="GlobalIDs"
        command="AddGlobalID"
        clean_command="RemoveAllGlobalIDs"
        repeat_command="1"
        number_of_elements_per_command="1"
        number_of_elements="1"
        update_self="1"
        label="Global IDs"
        default_values="0">
        <Documentation>
          This property contains the list of Global IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IntVectorProperty
        name="UseGlobalIDs"
        command="SetUseGlobalIDs"
        number_of_elements="1"
        update_self="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          If the value of this property is set to 1, GlobalIDs (instead of Indices) will be used for generating the selection.
        </Documentation>
     </IntVectorProperty>

     <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">
        </Proxy>
     </SubProxy>
   </ExtractSelectionProxy>

   <ExtractSelectionProxy name="ExtractCellSelection" 
      label="Extract Selection (cell)"
      class="vtkExtractSelection"
      selection_field_type="CELL" >
     <Documentation
        short_help="Extract selection by cell."
        long_help="Extract selection by cell." >
       This filter extracts a set of cells given a selection. 
       The selection can be obtained from a rubber-band selection 
       (either cell, visible or in a frustum) and passed to the filter 
       or specified by providing an ID list.
     </Documentation>

     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         This property specifies the input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <IdTypeVectorProperty 
        name="Indices"
        command="AddIndex"
        clean_command="RemoveAllIndices"
        repeat_command="1"
        number_of_elements_per_command="2"
        number_of_elements="2"
        update_self="1"
        label="Indices" 
        default_values="0 0">
        <Documentation>
          This property contains the list of IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IdTypeVectorProperty 
        name="GlobalIDs"
        command="AddGlobalID"
        clean_command="RemoveAllGlobalIDs"
        repeat_command="1"
        number_of_elements_per_command="1"
        number_of_elements="1"
        update_self="1"
        label="Global IDs"
        default_values="0">
        <Documentation>
          This property contains the list of Global IDs that will be added to the selection produced by the selection source.
        </Documentation>
     </IdTypeVectorProperty> 

     <IntVectorProperty
        name="UseGlobalIDs"
        command="SetUseGlobalIDs"
        number_of_elements="1"
        update_self="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          If the value of this property is set to 1, GlobalIDs (instead of Indices) will be used for generating the selection.
        </Documentation>
     </IntVectorProperty>

     <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">
        </Proxy>
     </SubProxy>
   </ExtractSelectionProxy>
-->
   <SourceProxy name="TimeToTextConvertor" class="vtkTimeToTextConvertor"
     label="Annotate Time" >
     <Documentation
        short_help="Show data time as text."
        long_help="Shows input data time as text annnotation in the view." >
        The Annotate Time filter can be used to show the data time in a text annotation.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <Documentation>
         This property specifies the input dataset for which to display the time.
       </Documentation>
     </InputProperty>
     <StringVectorProperty
       name="Format"
       command="SetFormat"
       number_of_elements="1"
       default_values="Time: %f">
       <Documentation>
         The value of this property is a format string used to display the input time. The format string is specified using printf style.
       </Documentation>
     </StringVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>

   <!-- End of TimeToTextConvertor -->
   </SourceProxy>

   <ExtractFrustumProxy name="SelectThrough"
    label="Select Through"
    class="vtkExtractSelection">
    <Documentation
       long_help="Draw a rubber band on the screen and select all cells behind it."
       short_help="Select cells behind a region of the screen.">
This extracts all cells within a frustum that is defined as the volume behind a chosen rectangular region of the screen.
    </Documentation>

     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">                   
        </Proxy>
        <ExposedProperties>
          <Property name="Frustum" /> 
          <Property name="ShowBounds" />
          <Property name="InsideOut" />
          <Property name="PreserveTopology" />
        </ExposedProperties>
     </SubProxy>

     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End SelectThrough -->
   </ExtractFrustumProxy>

   <ExtractThresholdsProxy name="ExtractThresholds"
                          class="vtkExtractSelection"
                          label="Extract Thresholds">
     <Documentation> 
This filter extracts a set of thresholds of its input.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <StringVectorProperty
         name="ScalarsArray" 
         command="SetScalarArray" 
         number_of_elements="5" 
         element_types="0 0 0 0 2" 
         update_self="1"
         animateable="0"> 
         <ArrayListDomain name="array_list" 
                          attribute_type="Scalars">
           <RequiredProperties>
              <Property name="Input" function="Input"/>
           </RequiredProperties>
         </ArrayListDomain>
         <FieldDataDomain name="field_list">
           <RequiredProperties>
              <Property name="Input" function="Input"/>
           </RequiredProperties>
         </FieldDataDomain>
         <Documentation>
           This property indicates the name of the array from which to threshold.
         </Documentation>
     </StringVectorProperty>

     <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">
        </Proxy>
        <ExposedProperties>
          <Property name="Thresholds" />
          <Property name="InsideOut" />
          <Property name="PreserveTopology" />
          <Property name="ContainingCells" />
        </ExposedProperties>
     </SubProxy>
     <!-- End ExtractThresholds -->
   </ExtractThresholdsProxy>
    
   <ExtractSelectionsProxy name="ExtractSelections"
      label="Extract Selections"
      class="vtkExtractSelection"
      selection_field_type="CELL" >
      <Documentation
         short_help="Extract different type of selections."
         long_help="Extract different type of selections." >
        This filter extracts a set of cells/points given a selection.
        The selection can be obtained from a rubber-band selection
        (either cell, visible or in a frustum) or threshold selection
        and passed to the filter or specified by providing an ID list.
      </Documentation>

      <InputProperty
          name="Input"
          command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input from which the selection is extracted.
        </Documentation>
      </InputProperty>

      <SubProxy>
        <Proxy name="SelectionSource" proxygroup="sources"
          proxyname="SelectionSource">
        </Proxy>
        <ExposedProperties>
          <Property name="ContentType" />
          <Property name="FieldType" />
          <Property name="ContainingCells" />
          <Property name="PreserveTopology" />
          <Property name="InsideOut" />
          <Property name="IDs" />
          <Property name="Locations" />
          <Property name="Thresholds" />
          <Property name="ArrayName" />
          <Property name="Frustum" />
          <Property name="ShowBounds" />
        </ExposedProperties>
      </SubProxy>
      <!-- End of ExtractSelections -->
    </ExtractSelectionsProxy>

    <SourceProxy name="ConvertSelection" class="vtkPConvertSelection">
      <Documentation>
        Converts a selection from one type to another.
      </Documentation>

      <InputProperty 
        name="DataInput"
        command="SetInputConnection"
        port_index="1">
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>
          Set the vtkDataObject input used to convert the selection.
        </Documentation>
      </InputProperty>

      <InputProperty
        name="Input"
        command="SetInputConnection"
        port_index="0">
        <DataTypeDomain name="input_type">
          <DataType value="vtkSelection" />
        </DataTypeDomain>
        <Documentation>
          Set the selection to convert.
        </Documentation>
      </InputProperty>

      <IntVectorProperty
        name="OutputType"
        command="SetOutputType"
        number_of_elements="1"
        default_values="5">
        <Documentation>
          Set the ContentType for the output.
        </Documentation>
        <EnumerationDomain name="enum">
          <Entry value="0" text="SELECTIONS" />
          <Entry value="1" text="COMPOSITE_SELECTIONS" />
          <Entry value="2" text="GLOBALIDs" />
          <Entry value="3" text="PEDIGREEIDS" />
          <Entry value="4" text="VALUES" />
          <Entry value="5" text="INDICES" />
          <Entry value="6" text="FRUSTUM" />
          <Entry value="7" text="LOCATION" />
          <Entry value="8" text="THRESHOLDS" />
        </EnumerationDomain>
      </IntVectorProperty>
      <!-- End of ConvertSelection -->
    </SourceProxy>

  </ProxyGroup>

</ServerManagerConfiguration>
